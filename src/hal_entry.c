#include "hal_data.h"
#ifdef USE_HRAM
#include "hram_sample.h"
#endif

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event)
BSP_PLACE_IN_SECTION(".warm_start");
FSP_CPP_FOOTER

extern uint32_t _ncbuffer_start;
extern uint32_t _ncbuffer_end;
extern uint32_t __sdnc_start__;
extern uint32_t __sdnc_end__;
extern uint32_t __Heap4_start__;
extern uint32_t __Heap4_end__;
extern uint32_t __bss_start__;
extern uint32_t __bss_end__;

static void bsp_sdram_init (void);
#define BSC_PROTECT_KEY     (0xa55a0000)

#ifdef USE_ETHERNET
void handle_error (fsp_err_t err);
void timer_callback (timer_callback_args_t * p_args);
uint64_t Get_Time_Stamp(void);
#if (defined(USE_RTOS) && !defined(RZT2_RSK_PNS))
#include "semphr.h"
extern  SemaphoreHandle_t uart_rx_semaphore;    // Semaphore to block task to wait for new UART RX
extern StaticSemaphore_t uart_rx_semaphorebuffer;
#endif
int64_t TimetStamp = 0;   /* countup integration time (ms) */
int32_t time_milli = 0;
int32_t time_sec   = 0;
#endif /* USE_ETHERNET */

#ifdef USE_HRAM
fsp_err_t hram_init(void);
void xspi_hram_init(void);
void xspi_hram_init_check(void);
fsp_err_t hram_trans(hram_transfer_t trans);
fsp_err_t check_ints(void);
uint16_t swap16(uint16_t value);
#endif

/*******************************************************************************************************************//**
 * main() is generated by the FSP Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
#ifndef USE_ETHERNET
#if INTCPU0_ENABLE

    /* Define the units to be used with the software delay function */
    const bsp_delay_units_t bsp_delay_units = BSP_DELAY_UNITS_MILLISECONDS;

    /* Set the blink frequency (must be <= bsp_delay_units */
    const uint32_t freq_in_hz = 2;

    /* Calculate the delay in terms of bsp_delay_units */
    const uint32_t delay = bsp_delay_units / freq_in_hz;

    /* LED type structure */
    bsp_leds_t leds = g_bsp_leds;
    
    /* If this board has no LEDs then trap here */
    if (0 == leds.led_count)
    {
        while (1)
        {
            ;                          // There are no LEDs on this board
        }
    }

    /* GIC settings for CPUINT0. */
    R_BSP_IrqCfgEnable(VECTOR_NUMBER_CPUINT0, 1, NULL);

    /* Enable interrupt. */
    __asm volatile ("cpsie i"); 

    while (1)
    {
        /* Generate INTCPU0. */
        R_ICU0->NS_SWINT = 0x00000001U;

        /* Delay */
        R_BSP_SoftwareDelay(delay, bsp_delay_units);
    }

#else
    /* Define the units to be used with the software delay function */
    const bsp_delay_units_t bsp_delay_units = BSP_DELAY_UNITS_MILLISECONDS;

    /* Set the blink frequency (must be <= bsp_delay_units */
    const uint32_t freq_in_hz = 2;

    /* Calculate the delay in terms of bsp_delay_units */
    const uint32_t delay = bsp_delay_units / freq_in_hz;

    /* LED type structure */
    bsp_leds_t leds = g_bsp_leds;

    /* If this board has no LEDs then trap here */
    if (0 == leds.led_count)
    {
        while (1)
        {
            ;                          // There are no LEDs on this board
        }
    }

    /* Holds level to set for pins */
    bsp_io_level_t pin_level = BSP_IO_LEVEL_LOW;

    while (1)
    {
        /* This code uses BSP IO functions to show how it is used.*/
        R_BSP_PinAccessEnable();

        /* Update all board LEDs */
        for (uint32_t i = 0; i < leds.led_count; i++)
        {
            /* Get pin to toggle */
            uint32_t pin = leds.p_leds[i];

            /* Write to this pin */
            R_BSP_PinWrite((bsp_io_port_pin_t) pin, pin_level);
        }

        /* Protect PFS registers */
        R_BSP_PinAccessDisable();

        /* Toggle level for next write */
        if (BSP_IO_LEVEL_LOW == pin_level)
        {
            pin_level = BSP_IO_LEVEL_HIGH;
        }
        else
        {
            pin_level = BSP_IO_LEVEL_LOW;
        }
        
        /* Delay */
        R_BSP_SoftwareDelay(delay, bsp_delay_units);
    }
#endif
#else
#ifndef RZT2_RSK_PNS
    fsp_err_t err;

    /* Open the transfer instance with initial configuration. */
    err = R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
    handle_error(err);

    r_sci_uart_baud_example();


    err = R_CMTW_Open(&g_timer0_ctrl, &g_timer0_cfg);
    handle_error(err);

    __asm volatile ("cpsie i"); 

    /* Start the timer. */
    (void) R_CMTW_Start(&g_timer0_ctrl);
    
    /* Enable compare match function. */
    (void) R_CMTW_Enable(&g_timer0_ctrl);
#endif
#endif
}

#ifdef USE_ETHERNET
/* Example callback called when timer expires. */
void timer_callback (timer_callback_args_t * p_args)
{
    TimetStamp++;   /* countup integration time (ms) */

    time_milli++;
    if( 1000 > time_milli)
    {
        return;
    }
    time_milli = 0;
    time_sec++;

#ifndef USE_RTOS
    if (TIMER_EVENT_CYCLE_END == p_args->event)
    {
        /* Add application code to be called periodically here. */
        /* LED type structure */
        bsp_leds_t leds = g_bsp_leds;

        /* This code uses BSP IO functions to show how it is used.*/
        R_BSP_PinAccessEnable();

        /* Update all board LEDs */
        for (uint32_t i = 0; i < leds.led_count; i++)
        {
            /* Get pin to toggle */
            uint32_t pin = leds.p_leds[i];

            /* Write to this pin */
            R_BSP_PinWrite((bsp_io_port_pin_t) pin, pin_level);
        }

        /* Protect PFS registers */
        R_BSP_PinAccessDisable();

        /* Toggle level for next write */
        if (BSP_IO_LEVEL_LOW == pin_level)
        {
            pin_level = BSP_IO_LEVEL_HIGH;
        }
        else
        {
            pin_level = BSP_IO_LEVEL_LOW;
        }
    }
#endif
}

uint64_t Get_Time_Stamp(void)
{
  return TimetStamp;
}
void handle_error (fsp_err_t err)
{
  ;
}

#endif

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);

#ifdef USE_HRAM
        /* Setup HyperRAM */
        hram_init();
#else
        /* Setup SDRAM */
        bsp_sdram_init();
#endif


#if __ICCARM__
        __iar_data_init3();
#else
        uint8_t * src_addr;     // Clear the .bss area to 0.
        uint8_t * dst_addr;
        uint8_t   zero = 0;

        src_addr = (uint8_t *) &_ncbuffer_start;
        dst_addr = (uint8_t *) &_ncbuffer_end;
        for (; src_addr < dst_addr; src_addr++)
        {
            *src_addr = zero;
        }

        src_addr = (uint8_t *) &__sdnc_start__;
        dst_addr = (uint8_t *) &__sdnc_end__;
        for (; src_addr < dst_addr; src_addr++)
        {
            *src_addr = zero;
        }

        src_addr = (uint8_t *) &__Heap4_start__;
        dst_addr = (uint8_t *) &__Heap4_end__;
        for (; src_addr < dst_addr; src_addr++)
        {
            *src_addr = zero;
        }

        src_addr = (uint8_t *) &__bss_start__;
        dst_addr = (uint8_t *) &__bss_end__;
        for (; src_addr < dst_addr; src_addr++)
        {
            *src_addr = zero;
        }

        /* Ensuring data-changing */
        __asm volatile ("dsb");
#endif
    }
}

#ifndef USE_HRAM
/*******************************************************************************************************************//**
 * @brief      Setup SDRAM controller
 *
 * @param[in]  void         none
 **********************************************************************************************************************/
static void bsp_sdram_init (void)
{
    volatile uint32_t val;

    R_RWP_S->PRCRS  = 0x0000A50F;
    R_RWP_NS->PRCRN = 0x0000A50F;

    /* NOTE: Port setting and CKIO configuration should have been done before */
    
    // Configure clock frequency
    val = R_SYSC_NS->SCKCR;
    val &= ~(7<<16);
    //val |=  (6<<16);	// CKIO clock: 25MHz 
    val |=  (1<<16);	// CKIO clock: 66.7MHz
    R_SYSC_NS->SCKCR = val;

    /* Enable BSC and CKIO module */
    val = R_SYSC_NS->MSTPCRA;
    val &= ~(1<<0);
    R_SYSC_NS->MSTPCRA = val;
    val = R_SYSC_NS->MSTPCRA;        // dummy read: step1

    // Enable CKIO module
    val = R_SYSC_NS->MSTPCRD;
    val &= ~(1<<11);
    R_SYSC_NS->MSTPCRD = val;
    val = R_SYSC_NS->MSTPCRD;        // dummy read: step1

    R_RWP_NS->PRCRN = 0x0000A500;
    R_RWP_S->PRCRS  = 0x0000A500;

    /* Wait */
	val = R_BSC->CSnBCR[3];        // dummy read: step2
	val = R_BSC->CSnBCR[3];        // dummy read: step2
	val = R_BSC->CSnBCR[3];        // dummy read: step2
	val = R_BSC->CSnBCR[3];        // dummy read: step2
	val = R_BSC->CSnBCR[3];        // dummy read: step2


    /* SDRAM:W9825G6KH-6 */
    /* Row address: A0-A12. Column address: A0-A8. */
	val = ( 2 <<  9)	// BSZ: data bus witdh: 16-bits
	 	| ( 1 << 11)	// Reserved
	 	| ( 4 << 12)	// TYPE: SDRAM
	 	| ( 0 << 16)	// IWRRS: Idle State Insertion between Read-Read Cycles in the Same CS Space
	 	| ( 0 << 19)	// IWRRD: Idle State Insertion between Read-Read Cycles in Different CS Spaces
	 	| ( 0 << 22)	// IWRWS: Idle State Insertion between Read-Write Cycles in the Same CS Space
	 	| ( 0 << 25)	// IWRWD: Idle State Insertion between Read-Write Cycles in Different CS Spaces
	 	| ( 0 << 28);	// IWW: Idle Cycles between Write-Read Cycles and Write-Write Cycles
    R_BSC->CSnBCR[3] = val;

    /* Wait cycle */
	val = ( 2 <<  0)	// WTRC: Number of Idle states frmo REF Command/Self-refresh relase to ACTV/REF/MRS command
	 	| ( 2 <<  3)	// TRWL: Number of Auto-precharge startup Wait Cycle
	 	| ( 1 <<  7)	// A3CL: CAS Latency: 2
	 	| ( 1 << 10)	// WTRCD: Number of Waits between ACTV command and READ/WRIT command
	 	| ( 1 << 13);	// WTRP: Number of Auto-precharge completion wait states        
        R_BSC->CS3WCR_1 = val;

    /* Wait */
	val = R_BSC->CSnBCR[2];        // dummy read: step2
	val = R_BSC->CSnBCR[2];        // dummy read: step2
	val = R_BSC->CSnBCR[2];        // dummy read: step2
	val = R_BSC->CSnBCR[2];        // dummy read: step2
	val = R_BSC->CSnBCR[2];        // dummy read: step2


    /* SDRAM:W9825G6KH-6 */
    /* Row address: A0-A12. Column address: A0-A8. */
	val = ( 2 <<  9)	// BSZ: data bus witdh: 16-bits
	 	| ( 1 << 11)	// Reserved
	 	| ( 4 << 12)	// TYPE: SDRAM
	 	| ( 0 << 16)	// IWRRS: Idle State Insertion between Read-Read Cycles in the Same CS Space
	 	| ( 0 << 19)	// IWRRD: Idle State Insertion between Read-Read Cycles in Different CS Spaces
	 	| ( 0 << 22)	// IWRWS: Idle State Insertion between Read-Write Cycles in the Same CS Space
	 	| ( 0 << 25)	// IWRWD: Idle State Insertion between Read-Write Cycles in Different CS Spaces
	 	| ( 0 << 28);	// IWW: Idle Cycles between Write-Read Cycles and Write-Write Cycles
    R_BSC->CSnBCR[2] = val;

    /* Wait cycle */
    val = ( 1 <<  7)	// A3CL: CAS Latency: 2
	 	| ( 1 << 10);	// Reserved 1

    R_BSC->CS2WCR_1 = val;

    /* SDRAM control */
    R_BSC->SDCR = 0x00110811;		// auto-refresh, auto-precharge mode, Col 9-bits, Row 13-bits

    /* Refresh setting for SDRAM */
    R_BSC->RTCOR = BSC_PROTECT_KEY 
                 | ( 29 <<  0);        // Refresh Time: 29 counts
    R_BSC->RTCSR = BSC_PROTECT_KEY 
                 | (  0 <<  7)         // Compare match Flag: clear
                 | (  0 <<  6)         // Compare match interrupt enable: Disabled
                 | (  2 <<  3)         // Refresh timer count clock: CKIO/16
                 | (  0 <<  0);        // Refresh count: 1 time

    /* wait 200us*/
    R_BSP_SoftwareDelay(200, BSP_DELAY_UNITS_MICROSECONDS);

    /* Power-on Sequence */
    /* Set mode register of SDRAM. needs wait for 2 SDRAM clock after set. */
    *((uint16_t *)0x80212040) = 0x0000;   // Burst length=1, Sequential, CL=2, Burst read and burst write
    *((uint16_t *)0x80211040) = 0x0000;   // Burst length=1, Sequential, CL=2, Burst read and burst write
  
}
#endif

#ifdef USE_HRAM
fsp_err_t hram_init(void)
{
    fsp_err_t err = FSP_SUCCESS;

    /* MDVn pin should be low(Set XSPI operating voltage at 1.8V) */
    uint32_t mdv = (R_SYSC_NS->MD_MON >> 16) & 0x1f;
    if ((0 << MDVn) != (mdv & (1 << MDVn)))
    {
        return FSP_ERR_ABORTED;
    }

    /* Cancels the XSPI module stop state. */
    R_BSP_RegisterProtectDisable(BSP_REG_PROTECT_LPC_RESET);
    R_BSP_MODULE_START(FSP_IP_XSPI, XSPIn);
    R_BSP_RegisterProtectEnable(BSP_REG_PROTECT_LPC_RESET);

    /* XSPI initial settings */
    xspi_hram_init();

    while(FSP_SUCCESS != err);

    /* Read HyperRAM register(The data read is big endian.) */
    /* Read setting of identification register 0 */
    volatile hram_transfer_t trans[2];
    // ran add--------------------------------------------start
        trans[0].cmd = 0x6000; //write cmd
        trans[0].addr = HRAM_DEVICE_CFG1_ADDR;
        trans[0].latency = 7;   // ran 6 change to 7
        trans[0].write = 1;
        trans[0].data  = 0x81FF;
        err = hram_trans(trans[0]);
        while(FSP_SUCCESS != err);
        trans[0].data  = 0xFFFF;
        //ran add-----------------------------------------------end
    trans[0].cmd = HRAM_DEVICE_READ_CMD;
    trans[0].addr = HRAM_DEVICE_ID0_ADDR;
    trans[0].latency = 7;   // ran  6 change to 7
    trans[0].write = false;
    err = hram_trans(trans[0]);
    while(FSP_SUCCESS != err);
    /* Since the data is big endian, convert the endian and output. */

    /* Read setting of identification register 1 */
    trans[0].addr = HRAM_DEVICE_ID1_ADDR;
    err = hram_trans(trans[0]);
    while(FSP_SUCCESS != err);

    /* Read setting of configuration register 0 */
    trans[0].addr = HRAM_DEVICE_CFG0_ADDR;
    err = hram_trans(trans[0]);
    while(FSP_SUCCESS != err);

    /* Read setting of configuration register 1 */
    trans[0].addr = HRAM_DEVICE_CFG1_ADDR;
    err = hram_trans(trans[0]);
    while(FSP_SUCCESS != err);

    return err;
}

/*******************************************************************************************************************//**
 * Function Name: xspi_hram_init
 * Description  : set xspi registers
 * Arguments    : none
 * Return Value : none
 **********************************************************************************************************************/
void xspi_hram_init(void)
{
    /* xSPI CS Size Control Register: 0x0000_3F3F */
    R_XSPIn->CSSCTL_b.CS0SIZE = 64 - 1; // CS0 (slave0) size  : 64MB
    R_XSPIn->CSSCTL_b.CS1SIZE = 64 - 1; // CS1 (slave1) size  : 64MB

    /* xSPI Wrapper Configuration Register: 0x0C00_0000 */
    R_XSPIn->WRAPCFG_b.DSSFTCS1 = 12;   // DS shift for slave0: Add a delay of 12 cells

    /* xSPI Link I/O Configuration Register CSn: 0x0037_0FFF */
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].PRTMD = 0x3FF; // Protocol mode  : 8D-8D-8D
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].LATEMD = 1;    // Latency mode   : Variable latency
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].WRMSKMD = 1;   // Write mask mode: Enable
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].CSMIN = 7;     // CS minimum idle term : 6 cycles
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].CSASTEX = 1;   // CS assert extension  : 1 cycle
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].CSNEGEX = 1;   // CS negating extension: 1 cycle
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].SDRDRV = 0;    // SDR driving timing   : Drive at 1/2 cycle before CK rising-edge
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].SDRSMPMD = 0;  // SDR Sampling mode    : Samples data input at falling-edge
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].SDRSMPSFT= 0;  // SDR Sampling window shift : Sample without delay
    R_XSPIn->LIOCFGCS_b[XSPIn_CS].DDRSMPEX = 0;  // DDR sampling window extend: Expand no cycle

    /* xSPI Common Configuration Register: 0x0003_0000 */
    R_XSPIn->COMCFG_b.OEASTEX = 1; // Output Enable Asserting extension: Enable
    R_XSPIn->COMCFG_b.OENEGEX = 1; // Output Enable Negating extension : Enable

    /* xSPI Bridge Map Configuration Register: 0x0000_0001 */
    R_XSPIn->BMCFG_b.WRMD = 1;     // AHB Write Response mode: Return response after issuing write transaction to xSPI bus
    R_XSPIn->BMCFG_b.MWRCOMB = 0;  // Memory Write Combination mode: Disable
    R_XSPIn->BMCFG_b.MWRSIZE = 0;  // Memory Write Size: Combine incremental address up to 4 bytes
    R_XSPIn->BMCFG_b.PREEN = 0;    // Prefetch enable  : Disable

    /* xSPI Command Map Configuration Register 0 CSn: 0x00FF_000F */
    R_XSPIn->CSa[XSPIn_CS].CMCFG0_b.FFMT = 3;       // Frame format: 8D-8D-8D profile 2.0 Commands with Extended Command Modifier format
    R_XSPIn->CSa[XSPIn_CS].CMCFG0_b.ADDSIZE = 3;    // Address size: 4 bytes (4 GB address space)
    R_XSPIn->CSa[XSPIn_CS].CMCFG0_b.ADDRPEN = 0xff; // Address Replace Enable: Replacement
    R_XSPIn->CSa[XSPIn_CS].CMCFG0_b.ADDRPCD = 0x00; // Address Replace Code

    /* xSPI Command Map Configuration Register 1 CSn: 0x0006_A000 */
    R_XSPIn->CSa[XSPIn_CS].CMCFG1_b.RDCMD = 0xa000; // Read command
    R_XSPIn->CSa[XSPIn_CS].CMCFG1_b.RDLATE = 7;     // Read latency cycle : 6 cycles

    /* xSPI Command Map Configuration Register 2 CSn: 0x0006_2000 */
    R_XSPIn->CSa[XSPIn_CS].CMCFG2_b.WRCMD = 0x2000; // Write command
    R_XSPIn->CSa[XSPIn_CS].CMCFG2_b.WRLATE = 7;     // Write latency cycle: 6 cycles

    /* xSPI Command Map Control Register: 0x0000_0000 */
    R_XSPIn->CMCTL = 0x00000000;   // Not using XiP mode

    /* xSPI Bridge Map Control Register 0: 0x0000_000F */
    R_XSPIn->BMCTL0_b.CS0ACC = 3;  // AHB channel to slave0 memory area access enable: Read/Write enable
    R_XSPIn->BMCTL0_b.CS1ACC = 3;  // AHB channel to slave1 memory area access enable: Read/Write enable

    /* xSPI Bridge Map Control Register 1: 0x0000_0500 */
    R_XSPIn->BMCTL1_b.MWRPUSH = 1; // Memory Write Data Push: Push request
    R_XSPIn->BMCTL1_b.PBUFCLR = 1; // Prefetch Buffer clear : Push request
}

/*******************************************************************************************************************//**
 * Function Name: hram_trans
 * Description  : Transfer HyperRAM
 * Arguments    : hram_transfer_t trans
 * Return Value : fsp_err_t err
 **********************************************************************************************************************/
fsp_err_t hram_trans(hram_transfer_t trans)
{
    fsp_err_t err = FSP_SUCCESS;

    /* xSPI Command Manual Type Buf */
    R_XSPIn->BUF[0].CDT_b.CMDSIZE = 2;  // Command Size: 2 bytes
    R_XSPIn->BUF[0].CDT_b.ADDSIZE = 4;  // Address Size: 4 bytes
    R_XSPIn->BUF[0].CDT_b.DATASIZE = 2; // Write/Read Data Size: 2 bytes
    R_XSPIn->BUF[0].CDT_b.LATE = trans.latency; // Latency cycle
    R_XSPIn->BUF[0].CDT_b.TRTYPE = trans.write; // Transaction Type
    R_XSPIn->BUF[0].CDT_b.CMD = trans.cmd;      // Command (1-2 bytes)
    /* xSPI Command Manual Address Buf */
    R_XSPIn->BUF[0].CDA  = trans.addr;

    /* For write transactions, write data to buffer registers */
    if (true == trans.write)
    {
        R_XSPIn->BUF[0].CDD0 = trans.data;
    }

    /* xSPI Command Manual Control Register 0 */
    R_XSPIn->CDCTL0_b.CSSEL = XSPIn_CS; // Chip select
    R_XSPIn->CDCTL0_b.TRNUM = 0;  // Transaction number: Issue 1 command (using command buffer 0)
    R_XSPIn->CDCTL0_b.PERMD = 0;  // Periodic mode: Direct manual-command mode
    R_XSPIn->CDCTL0_b.PERITV = 0; // Periodic transaction interval: 2 cycles
    FSP_HARDWARE_REGISTER_WAIT(R_XSPIn->CDCTL0_b.TRREQ, 0); // Wait for transaction completion
    R_XSPIn->CDCTL0_b.TRREQ = 1;  // Transaction request: Request transaction
    /* xSPI Interrupt Status Register */
    FSP_HARDWARE_REGISTER_WAIT(R_XSPIn->INTS_b.CMDCMP, 1);  // Wait for requested manual command completion
    /* xSPI Interrupt Clear Register */
    R_XSPIn->INTC_b.CMDCMPC = 1;  // Command Completed interrupt clear: Clear interrupt status

    /* DS Timeout and AHB Bus Error Detection */
    err = check_ints();
    while(FSP_SUCCESS != err)
    {
        return err;
    }

    /* For read transactions, read data from buffer registers. */
    if (false == trans.write)
    {
        trans.data = R_XSPIn->BUF[0].CDD0;
    }

    return err;
}

/*******************************************************************************************************************//**
 * Function Name: check_ints
 * Description  : DS Timeout and AHB Bus Error Detection
 * Arguments    : none
 * Return Value : none
 **********************************************************************************************************************/
fsp_err_t check_ints(void)
{
    /* AHB bus error detection */
    if (R_XSPIn->INTS_b.BUSERR)
    {
        R_XSPIn->INTC_b.BUSERRC = 1;
        return FSP_ERR_ABORTED;
    }
    /* DS timeout detection */
    if (XSPIn_DSTOCS)
    {
        XSPIn_DSTOCS_C = 1;
        return FSP_ERR_ABORTED;
    }

    return FSP_SUCCESS;
}

/*******************************************************************************************************************//**
 * Function Name: swap16
 * Description  : Convert endian
 * Arguments    : uint16_t value
 * Return Value : return ret
 **********************************************************************************************************************/
uint16_t swap16(uint16_t value)
{
    uint16_t ret;
    ret  = value << 8;
    ret |= value >> 8;
    return ret;
}
#endif

