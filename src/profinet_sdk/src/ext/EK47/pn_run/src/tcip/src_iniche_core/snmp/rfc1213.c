/*
 * v3.1 February 17, 2012 snmp/rfc1213.c (bugfixes)
 * v3.1 August 30, 2011 snmp/rfc1213.c
 * Distributed per ref EMEA2011-3
 */
/*
 * FILENAME: rfc1213.c
 * Implements MIB-II for InterNiche TCPIP stack.
 * If InterNiche TCPIP stack is not used, then skel1213.c
 * can be used as a starting point.
 *
 * Copyright 1990-96 by NetPort Software. All rights reserved.
 * Copyright 1996-2004 By InterNiche Technologies Inc. All rights reserved.
 *
 * MODULE: SNMP
 *
 * ROUTINES: var_system(), var_sysOREntry(), var_interfaces(), var_ifEntry(),
 * ROUTINES: add_atEntry(), var_atEntry(), var_ip(), var_ipAddrEntry(),
 * ROUTINES: var_ipRouteEntry(), add_ipNetToMediaEntry(), var_ipNetToMediaEntry(), var_icmp(),
 * ROUTINES: var_tcp(), var_tcpConnEntry(), var_udp(), var_udpEntry(),
 * ROUTINES: var_egp(), var_egpNeighEntry(), var_snmp(),
 * ROUTINES: var_snmpTrap(), var_snmpSet(),
 *
 * PORTABLE: yes
 */


/* RFC1213.c - C code file Generated by NetPort Software MIB Compiler
 * This file is meant to be renamed and hand edited to implement the
 * MIB on the target platform. Areas that need work are flagged 'TODO'
 *
 * For InterNiche TCP/IP var_tcpConnEntry() and var_egp() are not
 * populated. var_egp() is no populated because we don't support EGP.
 *
 * For Windows Sockets demo, only the system and SNMP groups have
 * been populated.
 *
 */

#include "ipport.h"
#include "snmpport.h"


#ifdef INCLUDE_SNMP
#ifdef INICHE_TCPIP

#include "q.h"
#include "netbuf.h"
#include "net.h"
#include "ip.h"
#include "arp.h"
#include "icmp.h"
#include "udp.h"

#include "asn1.h"
#include "npsnmp.h"
#include "snmp_imp.h"
#include "snmp_var.h"

#if 1 /*INICHE_TCIP_ITGR */
#include "tcpport.h"
#include "in_pcb.h"

char     sys_descr[SYS_STRING_MAX]; /* set in ip_glob_var_init() */
char     sysContact[SYS_STRING_MAX]; /* set in ip_glob_var_init() */
char     sysLocation[SYS_STRING_MAX]; /* set in ip_glob_var_init() */
char     sysName[SYS_STRING_MAX]; /* set in ip_glob_var_init() */

oid      sys_id[] = {0,0};
#endif

unsigned sys_id_len = sizeof(sys_id)/sizeof(oid);
oid      oid00[] = {0,0};     /* Object Id for ipRouteInfo, etc */
long     long_return =  0L;
u_char   return_buf[64] =  {0};

/* size of largest available buffer; from ..\net\pktalloc.c */
extern   unsigned bigbufsiz;

/* According to RFC2576 (sec 3.1), we have the following OID
 * mappings of generic trap types
 *  generic-trap parameter   snmpTrapOID.0
 *  ======================   =============
 *  0                        1.3.6.1.6.3.1.1.5.1 (coldStart)
 *  1                        1.3.6.1.6.3.1.1.5.2 (warmStart)
 *  2                        1.3.6.1.6.3.1.1.5.3 (linkDown)
 *  3                        1.3.6.1.6.3.1.1.5.4 (linkUp)
 *  4                        1.3.6.1.6.3.1.1.5.5 (authenticationFailure)
 *  5                        1.3.6.1.6.3.1.1.5.6 (egpNeighborLoss)
 *
 * Hence snmpgenoid[] is used to do the mapping. Based on "int trapType",
 * snmpgenoid[] is updated and used to form the varbind in the PDU
 */

/* As sys_uptime[], snmptrapoid[] and snmpgenoid[] are used by
 * other files, its better to put a fixed size, instead of [].
 * Previously they were specified with [] and that made some compilers
 * (VC++ 6.0) generate bad code (sys_uptime would point to 0x01)
 * at point of use
 */
oid      sys_uptime[9] = { 1,3,6,1,2,1,1,3,0 } ;
unsigned sys_uptime_len = sizeof ( sys_uptime )/sizeof(oid);
oid      snmptrapoid[11] = { 1,3,6,1,6,3,1,1,4,1,0 } ;
unsigned snmptrapoid_len = sizeof ( snmptrapoid )/sizeof(oid);
oid      snmpgenoid[11] = { 1,3,6,1,6,3,1,1,5,1,0 } ;

/* according to rfc3418.mib, here are values for sysServices
 * layer      functionality
 *   1        physical (e.g., repeaters)
 *   2        datalink/subnetwork (e.g., bridges)
 *   3        internet (e.g., supports the IP)
 *   4        end-to-end  (e.g., supports the TCP)
 *   7        applications (e.g., supports the SMTP)
 */
long sys_services = TCIP_CFG_SYS_SERVICES; /* layers 3,4,7 (bits 2,3,6) supported (INICHE_TCIP_ITGR 0x46->config) */


/* 'var_' routine frames for variables table */

/* FUNCTION: var_system()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     varlen
 *
 * RETURNS:
 */

u_char *
var_system(
   struct variable * vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   if (vp->acl == RWRITE)  /* force string length checking on sets */
   {
      set_parms.do_range = TRUE;
      set_parms.hi_range = SYS_STRING_MAX-1;
      set_parms.lo_range = 0;
   }

   switch (vp->magic)
   {
   case SYSDESCR:
      *var_len = strlen(sys_descr);
      return (u_char *)sys_descr;
   case SYSOBJECTID:
      *var_len = sizeof(sys_id);
      return (u_char *)sys_id;
   case SYSUPTIME:
      long_return =  ((cticks *  100)/TPS);
      return (u_char*)&long_return;
   case SYSCONTACT:
      *var_len = strlen(sysContact);
      return (u_char*)sysContact;
   case SYSNAME:
      *var_len = strlen(sysName);
      return (u_char*)sysName;
   case SYSLOCATION:
      *var_len = strlen(sysLocation);
      return (u_char*)sysLocation;
   case SYSSERVICES:
      return (u_char *)&sys_services;
#ifdef SYSORLASTCHANGE
   case SYSORLASTCHANGE:
      long_return = 0 ; /* no change occured since system startup */
      return (u_char*)&long_return;
#endif
   default:
      SNMPERROR("var_system: Unknown magic number");
   }
   return NULL;   /* default FAIL return. */
}

#ifdef SYSORINDEX

/* FUNCTION: var_sysOREntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * The System Object Resources Table (from rfc3418)
 * Implement it only if rfc3418 is compiled in.
 * Hence implement only if SYSORINDEX is already defined.
 *
 * If more MIBs are supported, they should be added to this table.
 * To add an entry to this table, do the following
 * 1. Update SYSOR_NUM
 * 2. Add ODI, len at end of sysOR_oid[]
 * 3. Add an entry to sysOR_table[]
 *
 * RETURNS: Pointer to value of variable. NULL if OID is not supported.
 *
 */

#define SYSORDES1 "The MIB module to describe generic objects for network interface sub-layers."
#define SYSORDES2 "The MIB module for SNMPv2 entities."
#define SYSORDES3 "The MIB module for managing TCP implementations."
#define SYSORDES4 "The MIB module for managing IP and ICMP implementations"
#define SYSORDES5 "The MIB module for managing UDP implementations"
#define SYSORDES6 "View-based Access Control Model for SNMP."
#define SYSORDES7 "The SNMP Management Architecture MIB."
#define SYSORDES8 "The MIB for Message Processing and Dispatching."
#define SYSORDES9 "The management information definitions for the SNMP User-based Security Model."

#define SYSOR_NUM 9   /* number of Object Resources */

/* define a structure that holds the OID and its len */
struct OidAndLen
{
   oid id[MAX_NAME_LEN];
   int len;
};

/* define the list of Object Resources supported */
struct OidAndLen sysOR_oid[SYSOR_NUM] =
{
   {{1,3,6,1,2,1,2}, 7},         /* interfaces */
   {{1,3,6,1,6,3,1}, 7},         /* SNMPv2 */
   {{1,3,6,1,2,1,6}, 7},         /* TCP */
   {{1,3,6,1,2,1,4}, 7},         /* IP */
   {{1,3,6,1,2,1,7}, 7},         /* UDP */
   {{1,3,6,1,6,3,16,2,2,1}, 10}, /* VACM */
   {{1,3,6,1,6,3,10,3,1,1}, 10}, /* SNMPv3 */
   {{1,3,6,1,6,3,11,3,1,1}, 10}, /* MPD */
   {{1,3,6,1,6,3,15,2,1,1}, 10}  /* USM */
};

struct sysOREntry_mib sysOR_table[SYSOR_NUM] =
{
   { 1, NULL, (void *)SYSORDES1, 0 },
   { 2, NULL, (void *)SYSORDES2, 0 },
   { 3, NULL, (void *)SYSORDES3, 0 },
   { 4, NULL, (void *)SYSORDES4, 0 },
   { 5, NULL, (void *)SYSORDES5, 0 },
   { 6, NULL, (void *)SYSORDES6, 0 },
   { 7, NULL, (void *)SYSORDES7, 0 },
   { 8, NULL, (void *)SYSORDES8, 0 },
   { 9, NULL, (void *)SYSORDES9, 0 },
};

u_char *
var_sysOREntry(
   struct variable * vp,   /* IN - pointer to variables[] entry */
   oid *   name,      /* IN/OUT - input name requested; output name found */
   int *   length,      /* IN/OUT - length of input & output oids */
   int   oper,      /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *   var_len)   /* OUT - length of variable, or 0 if function */
{
   unsigned   index;
   oid   newname[MAX_NAME_LEN];
   int   result;
   unsigned tbllen = SYSOR_NUM;

#ifndef INCLUDE_SNMPV3
   tbllen = 5;  /* don't include SNMPv3 related entries */
#endif
   MEMCPY((char *)newname, (char *)vp->name, (int)vp->namelen * sizeof(oid));

   /* find the index */
   for (index = 0; index < tbllen; index++)
   {
      newname[10] = (oid)((u_long)index + 1);
      result = compare(name, *length, newname, (int)vp->namelen);
      if ((oper && (result == 0)) || (!oper && (result < 0)))
         break;
   }

   if (index >= tbllen)
      return(NULL);

   MEMCPY((char *)name, (char *)newname, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default to 32 bit return */

   switch (vp->magic)
   {
   case SYSORID:
      *var_len = sysOR_oid[index].len * sizeof(oid);
      return (u_char *) sysOR_oid[index].id;
   case SYSORDESCR:
      *var_len = strlen((char *)(sysOR_table[index].sysORDescr));
      return (u_char *) sysOR_table[index].sysORDescr;
   case SYSORUPTIME:
      return (u_char *) &sysOR_table[index].sysORUpTime;
   }

   return NULL;   /* default FAIL return.*/
}

#endif /* ifdef SYSORINDEX */


/* FUNCTION: var_interfaces()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_interfaces(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY((char *)name, (char *)vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   long_return =  (u_long)ifNumber;
   return (u_char*)&long_return;
}



/* FUNCTION: var_ifEntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_ifEntry(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   unsigned   iface; /* INICHE_TCIP_ITGR changed interface to iface, because interface is a C++ keyword */
   oid   newname[MAX_NAME_LEN];
   IFMIB   ifp;
   int   result;

   MEMCPY((char *)newname, (char *)vp->name, (int)vp->namelen * sizeof(oid));

   /* find "next" interface */
   for (iface = 0; iface < ifNumber; iface++)
   {
      newname[10] = (oid)((u_long)iface + 1);
      result = compare(name, *length, newname, (int)vp->namelen);
      if ((oper && (result == 0)) || (!oper && (result < 0)))
         break;
   }

   if (iface >= ifNumber) return(NULL);


   MEMCPY((char *)name, (char *)newname, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default to 32 bit return */

   ifp = nets[iface]->n_mib;

   switch (vp->magic)
   {
   case IFINDEX:        /* we store 'em 0 thru n-1, snmp wants 1 thru n */
      long_return =  ifp->ifIndex   +  1;
      return (u_char *)&long_return;
   case IFDESCR:
      *var_len = strlen((char*)ifp->ifDescr);
      return (u_char *)ifp->ifDescr;
   case IFPHYSADDRESS:
      *var_len = nets[iface]->n_hal;
      return (u_char *)ifp->ifPhysAddress;
   case IFLASTCHANGE:
#if 1 /* INICHE_TCIP_ITGR */
      long_return = (ifp->ifLastChange);
#else
      long_return =  ((cticks *  100)/TPS);
#endif
      return (u_char*)&long_return;
   case IFSPECIFIC:     /* cound be Oid of ethernet MIB later. */
      *var_len = sizeof(oid00);
      return((u_char*)oid00);

#if 1 /* INICHE_TCIP_ITGR, see Request ID 216015 */
/* sanity */
#if IFINOCTETS != 9*4 || EDD_MIB_SUPPORT_INOCTETS != 0x0001 || \
	IFINUCASTPKTS != 10*4 || EDD_MIB_SUPPORT_INUCASTPKTS != 0x0002 || \
	IFINNUCASTPKTS != 11*4 || EDD_MIB_SUPPORT_INNUCASTPKTS != 0x0004 || \
	IFINDISCARDS != 12*4 || EDD_MIB_SUPPORT_INDISCARDS != 0x0008 || \
	IFINERRORS != 13*4 || EDD_MIB_SUPPORT_INERRORS != 0x0010 || \
	IFINUNKNOWNPROTOS != 14*4 || EDD_MIB_SUPPORT_INUNKNOWNPROTOS != 0x0020 || \
	IFOUTOCTETS != 15*4 || EDD_MIB_SUPPORT_OUTOCTETS != 0x0040 || \
	IFOUTUCASTPKTS != 16*4 || EDD_MIB_SUPPORT_OUTUCASTPKTS != 0x0080 || \
	IFOUTNUCASTPKTS != 17*4 || EDD_MIB_SUPPORT_OUTNUCASTPKTS != 0x0100 || \
	IFOUTDISCARDS != 18*4 || EDD_MIB_SUPPORT_OUTDISCARDS != 0x0200 || \
	IFOUTERRORS != 19*4 || EDD_MIB_SUPPORT_OUTERRORS != 0x0400 || \
	IFOUTQLEN != 20*4 || EDD_MIB_SUPPORT_OUTQLEN != 0x0800
#error
#endif
	case IFINOCTETS:
	case IFINUCASTPKTS:
	case IFINNUCASTPKTS:
	case IFINDISCARDS:
	case IFINERRORS:
	case IFINUNKNOWNPROTOS:
	case IFOUTOCTETS:
	case IFOUTUCASTPKTS:
	case IFOUTNUCASTPKTS:
	case IFOUTDISCARDS:
	case IFOUTERRORS:
	case IFOUTQLEN:
	{
		u_long mask;
		u_long shift = vp->magic;
		shift -= IFINOCTETS;
		shift /= 4;
		mask = (1UL << shift);
		if ((mask & ifp->SupportedCounters) != 0)
		{
			return (u_char *)(((char *)ifp) + vp->magic);
		}
		else
		{
			if (oper != NEXT_OP)
			{
				return NULL; /* not supported by EDD, see edd_usr.h */
			}
			else /* must search for value on this hierarchy level */
			{
				for(; iface<ifNumber; iface++)
				{
					ifp = nets[iface]->n_mib;

					if ((mask & ifp->SupportedCounters) != 0)
					{
						name[10] = (iface+1);

						return (u_char *)(((char *)ifp) + vp->magic);
					}
				}

				return NULL;
			}
		}
	}
#endif

      default:
      return (u_char *)(((char *)ifp) + vp->magic);

   }
}

#define  IF_OIDLEN   16    /* length of address table ObjIds */


#ifdef BORLANDC
#pragma argsused
#endif   /* BORLANDC */


/* FUNCTION: add_atEntry()
 *
 * PARAM1: u_char  *var_val
 * PARAM2: u_char  var_val_type
 * PARAM3: int      var_val_len
 * PARAM4: u_char  *statP
 * PARAM5: int      statLen
 *
 * Address Translation table add entry routine.
 *
 * RETURNS:
 * returns an snmp error from npsnmp.h (0 == no error)
 */

int
add_atEntry(u_char  * var_val,   /* pointer to asn1 encoded set value ??? */
   u_char   var_val_type,  /* asn1 type of set value */
   int      var_val_len,   /* length of set value */
   u_char  *   statP,      /* pointer returned by var_atEntry */
   int      statLen)       /* *var_len" from var_atEntry */
{
   unsigned iface;      /* interface from ObjectId index */
   struct   arptabent * atp;  /* scratch pointer to table entries */
   ip_addr  arp_ip;
   u_char   mac_buf[6];
   unsigned asnbuf_len=20; /* for pass to asn1 parser */
   u_char   asn_type;   /* byte for pass to asn1 parser */
   struct variable * vp =  set_parms.vp;

   USE_ARG(statP);
   USE_ARG(statLen);
   USE_ARG(var_val_type);

   /* set index variables from Object Id passed */
   oid2bytes((char*)(&arp_ip), set_parms.name + 12, 4); /* extract IP addr */
   iface = (int)*(set_parms.name + 10);  /* extract iface number */

   /* sanity check iface parm */
   if (iface > ifNumber)
   {
      if (vp->magic == ATIFINDEX)
         return SNMP_ERR_BADVALUE;
      else
         return SNMP_ERR_NOSUCHNAME;
   }

   /* see if we need to make new arp entry */
   for (atp = arp_table; atp < arp_table + MAXARPS; atp++)
      if (atp->t_pro_addr == arp_ip)
      break;

   if (atp->t_pro_addr != arp_ip)   /* no entry, make new one */
   {
      atp = make_arp_entry(arp_ip, nets[iface]);   /* make new arp entry */
   }
   else     /* update existing entry */
   {
      switch (vp->magic)
      {
      case ATIFINDEX:
         /* parse the received value */
         asn_parse_int(var_val, (unsigned int *)&asnbuf_len,
            &asn_type, &long_return,sizeof(long));
         /* index to set was left in long_return */
         if ((long_return < 1) || (long_return > (long)ifNumber))
            return SNMP_ERR_BADVALUE;
         atp->net = nets[(int)long_return-1];
         break;
      case ATPHYSADDRESS:
         if (var_val_len > 6) /* limit data to size of ether address */
            return SNMP_ERR_BADVALUE;
         asn_parse_string(var_val, &asnbuf_len, &asn_type, mac_buf, (unsigned*)&var_val_len);
         if (var_val_len == 0)   /* station is trying to delete arp entry */
            atp->t_pro_addr = 0L;   /* mark it deleted */
         else
            MEMCPY(atp->t_phy_addr, mac_buf, 6);
         break;
      case ATNETADDRESS:
         if (var_val_len > 4) /* limit data to size of IP address */
            return SNMP_ERR_BADVALUE;
         asn_parse_string(var_val, &asnbuf_len, &asn_type,
            (unsigned char *)&(atp->t_pro_addr), (unsigned*)&var_val_len);
         break;
      default:       /* shouldn't happen */
         dtrap();
      }
   }
   return SNMP_ERR_NOERROR;
}



/* FUNCTION: var_atEntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_atEntry(
   struct variable *    vp, /* IN - pointer to variables[] entry */
   oid *    name,           /* IN/OUT - input name requested; output name found */
   int *    length,         /* IN/OUT - length of input & output oids */
   int   oper,              /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len)        /* OUT - length of variable, or 0 if function */
{
#if 1 /* INICHE_TCIP_ITGR atTable has status obsolete */
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);

   return NULL;
#else
   oid   lowest[DEF_VARLEN];        /* "best fit" object Id */
   oid   current[DEF_VARLEN];
   struct arptabent *   atp;        /* scratch pointer to table entries */
   struct arptabent *   lowarp   =  NULL; /* lowest entry we found */
   int   net;
   int   i;
   u_char * cp;

   /* always allow sets to table index vars: atIfIndex and atPhysAddress */
   if (oper == SET_OP)
   {
      ip_addr ipad;

      if (*length != 16) /* MUST have complete index! */
         return NULL;   /* NOSUCH error reply */

      /* leave set info in static area so add_atEntry() can find it */
      set_parms.access_method = add_atEntry;
      set_parms.vp = vp;
      set_parms.name = name;
      set_parms.vbflags |= SF_NOASCIICHK ; /* don't do is_us_ascii() check */

      /* find entry to be set (or replaced) */
      oid2bytes((char*)&ipad, name+12, 4);
      atp = find_oldest_arp(ipad);     /* find the entry */

      *var_len = sizeof(long);   /* default length return */

      /* return a pointer to where add_atEntry() will set the value: */
      switch (vp->magic)
      {
      case ATIFINDEX:
         long_return =  (long)name[10];
         return (u_char*)&long_return;
      case ATPHYSADDRESS:
         *var_len = 6;
         return (u_char*)atp->t_phy_addr;
      case ATNETADDRESS:
         long_return =  (long)ipad;
         return (u_char *)&long_return;
      }
   }

   /* fill in object part of name for current (less sizeof instance part) */
   MEMCPY((char *)current, (char *)vp->name, DEF_VARLEN * sizeof(oid) );

   /* scan at table for closest match */
   for (atp = arp_table; atp < arp_table + MAXARPS; atp++)
   {
      if (!atp->t_pro_addr)      /* if this entry isn't valid */
         continue;

      /* create object id reflecting this arp table entry's IP & iface */

      /* According to RFC1212 section 4.1.6
       *  (5)  NetworkAddress-valued: `n+1' sub-identifiers, where `n'
       *       depends on the kind of address being encoded (the first
       *       sub-identifier indicates the kind of address, value 1
       *       indicates an IpAddress); or,
       *
       * Hence we need to add a 1 before the IP address.
       */
      current[vp->namelen] = 1;

      /* copy IP address into current. */
      cp = (u_char*)&atp->t_pro_addr;
      for (i = vp->namelen+1; i < vp->namelen+5; i++) /* current[12] - current[15] */
         current[i] = *cp++;

      /* set interface index in objId */
      current[vp->namelen-1] = (oid)((u_long)if_netnumber(atp->net) + 1);

      if (oper)   /* operation is SET or GET */
      {
         if (compare(current, IF_OIDLEN, name, *length) == 0)
         {   MEMCPY((char *)lowest, (char *)current, (vp->namelen+5) * sizeof(oid));
            lowarp = atp;
            break;   /* no need to search further */
         }
      }
      else     /* caller wants closest match */
      {
         /* if new one is greater than input and closer to input than
          * previous lowest, save this one as the "next" one. */
         if ((compare(current, IF_OIDLEN, name, *length) > 0) &&
             (!lowarp || (compare(current, IF_OIDLEN, lowest, IF_OIDLEN) < 0)))
         {
            MEMCPY((char *)lowest, (char *)current, (vp->namelen+5) * sizeof(oid));
            lowarp = atp;
         }
      }

   }   /* end for at_mib loop */

   if (!lowarp) return(NULL); /* no match */

   MEMCPY((char *)name, (char *)lowest, (vp->namelen+5) * sizeof(oid));
   *length = (vp->namelen+5);

   net = (int)lowest[10];

   switch (vp->magic)
   {
   case ATIFINDEX:
      *var_len = sizeof long_return;
      long_return =  (unsigned   long)net;
      return (u_char *)&long_return;
   case ATPHYSADDRESS:
      MEMCPY((char *)return_buf, (char *)lowarp->t_phy_addr, 6);
      *var_len = 6;
      return (u_char *)return_buf;
   case ATNETADDRESS:
      *var_len = 4;
      return (u_char *)&lowarp->t_pro_addr;
      default:
      SNMPERROR("var_AtEntry: bad magic number");
   }
   return NULL;
#endif
}



/* FUNCTION: var_ip()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_ip(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   u_char * cp;   /* return value pointer */

   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   cp = (u_char*)&ip_mib;
   return(cp + vp->magic);
}



/* FUNCTION: var_ipAddrEntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_ipAddrEntry(
	struct variable *    vp,   /* IN - pointer to variables[] entry */
	oid *    name,       /* IN/OUT - input name requested; output name found */
	int *    length,  /* IN/OUT - length of input & output oids */
	int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
	int *    var_len) /* OUT - length of variable, or 0 if function */
{
	oid   newname[DEF_VARLEN];
	int   result;
	int   i;
	unsigned netnum;
	u_char * cp;
	NET   ifp = NULL;       /* pointer to netport link structs */
	NET   bestnext = NULL;
	oid    bestname[MAX_NAME_LEN];   /* Object Id of best next entry */
	int    bestlength  = *   length;

	if (oper == NEXT_OP)
	{
		bestnext = NULL;
		bestlength = *length;
		oidcpy(bestname, name, *length);
	}


	MEMCPY((char *)newname, (char *)vp->name, (int)vp->namelen * sizeof(oid));

	for (netnum = 0; netnum < ifNumber; netnum++)
	{
		ifp = nets[netnum];
		cp = (u_char*)&ifp->n_ipaddr;
		for (i = 10; i < vp->namelen+3; i++)
		{
			newname[i] = *cp++;
		}

		if (oper != NEXT_OP)
		{
			result = compare(name, *length, newname, (int)vp->namelen+3);
			if (result == 0)
			{
				break;      /* found exact match for set or get */
			}
		}
		else     /* operation is getnext */
		{
			if ((compare(newname, (int)vp->namelen+3, name, *length) > 0) &&
				(!bestnext || (compare(newname, (int)vp->namelen+3, bestname, bestlength) < 0)))
			{
				bestnext = ifp;   /* save new "best next" */
				bestlength = vp->namelen+3;
				oidcpy(bestname, newname, vp->namelen+3);
			}

		}
	}

	if( netnum == ifNumber )
	{
		if(oper == GET_OP)
		{
			return NULL;   /* not found */
		}
		else  /* oper == NEXT_OP */
		{
			if (bestnext)  /* found a valid "next" route */
			{
				ifp = bestnext;
				oidcpy(name, bestname, bestlength);
			}
			else
			{
				return NULL;
			}
		}
	}

	*length = vp->namelen + 3;
	*var_len = sizeof(long);

	switch (vp->magic)
	{
	case IPADENTADDR:
		return (u_char *)&(ifp->n_ipaddr);

	case IPADENTIFINDEX:          /* see ifIndex */
		long_return = ifp->mib.ifIndex+1; /* MIB wants range 1 - n */
		return (u_char *)&long_return;

	case IPADENTNETMASK:
		long_return =  ifp->snmask;
		return (u_char *)&long_return;

	case IPADENTBCASTADDR:
		/*       long_return = ifp->n_netbr & 1;      // just get low bit */
		long_return =  1L;      /* fix the line above later... */
		return (u_char *)&long_return;

	case IPADENTREASMMAXSIZE:
#ifdef HEAPBUFS
	/* if heap buffers are available, the largest IP datagram that can be
	* reassembled is equal to the max payload allowed ((2^16 - 1) - (size
	* of IP header)) */
	long_return = (0xFFFF - (sizeof (struct ip)));
#else
	/* if heap buffers are not available, the largest size of an IP datagram
	* that can be reassembled is constrained by what will fit inside a big
	* buffer */
	long_return =  ((long)bigbufsiz  -  34);
#endif
	return (u_char *)&long_return;

	default:
	SNMPERROR("var_ifAddrEntry: bad magic number");
	}

	return NULL;
}

#ifndef MINI_IP
#ifndef IP_ROUTING

#if 0 /* INICHE_TCIP_ITGR removed "double defined" already defined in rfc1213_.h! */
/* fake route table (single entry) for single homed system */
struct ipRouteEntry_mib {
        u_long  ipRouteDest;
        long    ipRouteIfIndex;
        long    ipRouteMetric1;
        long    ipRouteMetric2;
        long    ipRouteMetric3;
        long    ipRouteMetric4;
        u_long  ipRouteNextHop;
        long    ipRouteType;
        long    ipRouteProto;
        long    ipRouteAge;
        u_long  ipRouteMask;
        long    ipRouteMetric5;
        oid  *  ipRouteInfo;    /* 32 bit ptr */
};
#endif

struct ipRouteEntry_mib route_info  =  {
   0,    /* ipRouteDest; 0 means default */
   1,    /* ipRouteIfIndex; */
   -1,   /* ipRouteMetric1; */
   -1,   /* ipRouteMetric2; */
   -1,   /* ipRouteMetric3; */
   -1,   /* ipRouteMetric4; */
   ~0,   /* ipRouteNextHop;  */
   3,    /* ipRouteType; 3 means dirdctly connected */
   2,    /* ipRouteProto;2 means locally set.  */
   0,    /* ipRouteAge;  cticks */
   0,    /* ipRouteMask; */
   ~0,   /* ipRouteMetric5; */
   0,    /* ipRouteInfo; this is ugly, see rfc1213 description */
};
#endif   /* IP_ROUTING */
#endif   /* MINI_IP */



/* FUNCTION: var_ipRouteEntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_ipRouteEntry(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{

#ifdef IP_ROUTING    /* use the real route table for SNMP */
#ifdef BTREE_ROUTES
   /* we don't have a solution for BTREE routing table yet .. */
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);
   return NULL;
#else
   int    i;
   int    result;
   oid    newname[DEF_VARLEN];
   u_char *cp;
   RTMIB  rtp;
   RTMIB  free_rtp = NULL;
   RTMIB  bestnext = NULL;
   oid    bestname[MAX_NAME_LEN];   /* Object Id of best next entry */
   int    bestlength  = *   length;

   if (oper == NEXT_OP) /* set up to search for best next */
   {
      bestnext = NULL;
      bestlength = *length;
      oidcpy(bestname, name, *length);
   }

   MEMCPY((char *)newname, (char *)vp->name, (int)vp->namelen * sizeof(oid));

   /* find route table entry caller wants */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++) /* scan route table */
   {
      if (!rtp->ipRouteNextHop)
      {
         free_rtp = rtp;
         continue;   /* empty entry */
      }

      cp = (u_char *)&rtp->ipRouteDest;
      for (i = vp->namelen-1; i < vp->namelen+3; i++)     /* copy ip addr into newname */
         newname[i] = *cp++;

      if (oper != NEXT_OP)
      {
         result = compare(name, *length, newname, (int)vp->namelen+3);
         if (result == 0)
            break;      /* found exact match for set or get */
      }
      else     /* operation is getnext */
      {
         if ((compare(newname, (int)vp->namelen+3, name, *length) > 0) &&
			 (!bestnext || (compare(newname, (int)vp->namelen+3, bestname, bestlength) < 0)))
         {
            bestnext = rtp;   /* save new "best next" */
            bestlength = vp->namelen+3;
            oidcpy(bestname, newname, vp->namelen+3);
         }
      }
   }

   USE_ARG(free_rtp); /* INICHE_TCPIP_ITGR eliminate MIPS compiler warning "variable 'free_rtp' set but not used", see 1911686 */

   if (rtp >= (rt_mib + ipRoutes))     /* exact match not found */
   {
      /* If user is trying a SET, create new route entry */
      if (oper == SET_OP)
      {
#if 1 /* INICHE_TCIP_ITGR ipRouteTable is RONLY */
         return NULL;
#else
         ip_addr ipaddr;

         /* fill in scratch IP address for Object Id passed */
         oid2bytes((char*)&ipaddr, name+14, 4);
         add_route(ipaddr, 0xFFFFFFFFL, ipaddr, 0, IPRP_NETMGMT);
#endif
      }
      else if(oper == GET_OP)
         return NULL;   /* not found */
      else  /* oper == NEXT_OP */
      {
         if (bestnext)  /* found a valid "next" route */
         {
            rtp = bestnext;
            oidcpy(name, bestname, bestlength);
         }
         else
            return NULL;
      }
   }

   *length = vp->namelen + 3;
   *var_len = sizeof(long);

   switch (vp->magic)
   {
   case IPROUTEAGE:        /* our "age" is cticks when entry last used */
      /* Return approx seconds since last used. */
      long_return =  (cticks  -  rtp->ipRouteAge)/TPS;
      return((u_char *)&long_return);
   case IPROUTEINFO:
      *var_len = sizeof(oid00);
      return((u_char*)oid00);
   default:
      return (u_char *)(((u_char *)rtp) + vp->magic);
   }
#endif /* end of else of BTREE_ROUTES */

#else    /* not IP_ROUTING, do simple fake routing case */
#ifdef MINI_IP
   return NULL;
#else
/* this case fakes a route table to show a single net route to
 * our sole local interface.
 */
   int    i;
   int    result;
   oid    newname[DEF_VARLEN];
   u_char *cp;
   ip_addr netaddr;  /* net portion of our single if's IP address */

   netaddr = nets[0]->n_ipaddr & nets[0]->snmask;     /* route's IP dest */

   /* build oid to return, if we return non null */
   oidcpy(newname, vp->name, vp->namelen);   /* start with variable name */
   cp = (u_char *)(&netaddr);       /* add IP address index */
   for (i = 10; i < 14; i++)     /* copy ip addr into newname */
      newname[i] = *cp++;     /* ...be carefull of byte ordering */

   /* see if name falls within this routine's range */
   if (oper)   /* user did a get, must be exact match */
   {
      result = compare(name, 14, newname, 14);
      if (result != 0)
         return NULL;      /* no exact match */
   }
   else     /* not get or set, see if we have a good next */
   {
      result = compare(name, *length, newname, (int)vp->namelen);
      if (result > 0)
         return NULL;      /* not a valid next */
   }

   oidcpy(name, newname, 14);    /* return OID found */
   *length = 14;              /* length of OID found */
   *var_len = sizeof(long);   /* default variable len */

   route_info.ipRouteDest = netaddr;
   route_info.ipRouteMask = nets[0]->snmask;

   switch (vp->magic)
   {
   case IPROUTEAGE:        /* our "age" is cticks when entry last used */
      /* Return approx seconds since boot */
      long_return =  cticks/TPS;
      return((u_char*)&long_return);
   case IPROUTEINFO:
      *var_len = sizeof(oid00);
      return((u_char*)oid00);
   default:
      cp = (u_char*)(&route_info);
      return (cp + vp->magic);
   }
#endif /* else of MINI_IP */
#endif   /* IP_ROUTING */
}


/* FUNCTION: add_ipNetToMediaEntry()
 *
 * PARAM1: u_char  *var_val
 * PARAM2: u_char  var_val_type
 * PARAM3: int      var_val_len
 * PARAM4: u_char  *statP
 * PARAM5: int      statLen
 *
 * ipNetToMedia table add entry routine.
 *
 * RETURNS:
 * 0           - no error
 * nonzero     - returns a snmp error from npsnmp.h
 */

int
add_ipNetToMediaEntry(u_char  * var_val,   /* pointer to asn1 encoded set value ??? */
   u_char   var_val_type,  /* asn1 type of set value */
   int      var_val_len,   /* length of set value */
   u_char  *   statP,      /* pointer returned by var_atEntry */
   int      statLen)       /* *var_len" from var_atEntry */
{
   unsigned iface;            /* interface from ObjectId index */
   struct   arptabent * atp;  /* scratch pointer to table entries */
   ip_addr  arp_ip;
   u_char   mac_buf[6];
   unsigned asnbuf_len=20; /* for pass to asn1 parser */
   u_char   asn_type;   /* byte for pass to asn1 parser */
   struct variable * vp =  set_parms.vp;

   USE_ARG(statP);
   USE_ARG(statLen);
   USE_ARG(var_val_type);

   /* set index variables from Object Id passed */
   oid2bytes((char*)(&arp_ip), set_parms.name + 11, 4); /* extract IP addr */
   iface = (int)*(set_parms.name + 10);  /* extract iface number */

   /* sanity check iface parm */
   if (iface > ifNumber)
   {
      if (vp->magic == IPNETTOMEDIAIFINDEX)
         return SNMP_ERR_BADVALUE;
      else
         return SNMP_ERR_NOSUCHNAME;
   }

   /* see if we need to make new arp entry */
   for (atp = arp_table; atp < arp_table + MAXARPS; atp++)
      if (atp->t_pro_addr == arp_ip)
      break;

   if (atp->t_pro_addr != arp_ip)   /* no entry, make new one */
   {
      atp = make_arp_entry(arp_ip, nets[iface]);   /* make new arp entry */
   }
   else     /* update existing entry */
   {
      switch (vp->magic)
      {
      case IPNETTOMEDIAIFINDEX:
         /* parse the received value */
         asn_parse_int(var_val, (unsigned int *)&asnbuf_len,
            &asn_type, &long_return,sizeof(long));
         /* index to set was left in long_return */
         if ((long_return < 1) || (long_return > (long)ifNumber))
            return SNMP_ERR_BADVALUE;
         atp->net = nets[(int)long_return-1];
         break;
      case IPNETTOMEDIAPHYSADDRESS:
         if (var_val_len > 6) /* limit data to size of ether address */
            return SNMP_ERR_BADVALUE;
         asn_parse_string(var_val, &asnbuf_len, &asn_type, mac_buf,
            (unsigned*)&var_val_len);
         if (var_val_len == 0)   /* station is trying to delete arp entry */
            atp->t_pro_addr = 0L;   /* mark it deleted */
         else
            MEMCPY(atp->t_phy_addr, mac_buf, 6);
         break;
      case IPNETTOMEDIANETADDRESS:
         if (var_val_len > 4) /* limit data to size of IP address */
            return SNMP_ERR_BADVALUE;
         asn_parse_string(var_val, &asnbuf_len, &asn_type,
            (unsigned char *)&(atp->t_pro_addr), (unsigned*)&var_val_len);
         break;
      case IPNETTOMEDIATYPE: /* nothing to do - media type is assumed 3 */
         break;
      default:       /* shouldn't happen */
         dtrap();
      }
   }
   return SNMP_ERR_NOERROR;
}



/* FUNCTION: var_ipNetToMediaEntry()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_ipNetToMediaEntry(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   oid   lowest[DEF_VARLEN];        /* "best fit" object Id */
   oid   current[DEF_VARLEN];
   struct arptabent *   atp;        /* scratch pointer to table entries */
   struct arptabent *   lowarp   =  NULL; /* lowest entry we found */
   int i;
   u_char * cp;

#if 1 /* INICHE_TCIP_ITGR prevent LINT warning, see AP01235682 */
	lowest[0] = 0;
#endif
   /* always allow sets to table index vars:
    *    ipNetToMediaIfIndex and ipNetToMediaPhysAddress
    */
   if (oper == SET_OP)
   {
      ip_addr ipad;

      if (*length != IF_OIDLEN-1) /* MUST have complete index! */
         return NULL;   /* NOSUCH error reply */

      /* leave set info in static area so add_ipNetToMediaEntry() can find it */
      set_parms.access_method = add_ipNetToMediaEntry;
      set_parms.vp = vp;
      set_parms.name = name;
      set_parms.vbflags |= SF_NOASCIICHK ; /* don't do is_us_ascii() check */

      /* find entry to be set (or replaced) */
      oid2bytes((char*)&ipad, name+11, 4);
      atp = find_oldest_arp(ipad);     /* find the entry */

      *var_len = sizeof(long);   /* default length return */

      /* return a ptr to where add_ipNetToMediaEntry() will set the value */
      switch (vp->magic)
      {
      case IPNETTOMEDIAIFINDEX:
         long_return =  (long)name[10];
         return (u_char*)&long_return;
      case IPNETTOMEDIAPHYSADDRESS:
         *var_len = 6;
         return (u_char*)atp->t_phy_addr;
      case IPNETTOMEDIANETADDRESS:
         long_return =  (long)ipad;
         return (u_char *)&long_return;
      case IPNETTOMEDIATYPE:
         /* use the default mechanism to set this value */
         set_parms.access_method = NULL;
         long_return = 3;
         return (u_char *)&long_return;
      }
   }

   /* fill in object part of name for current (less sizeof instance part) */
   MEMCPY((char *)current, (char *)vp->name, DEF_VARLEN * sizeof(oid) );

   /* scan at table for closest match */
   for (atp = arp_table; atp < arp_table + MAXARPS; atp++)
   {
      if (!atp->t_pro_addr)      /* if this entry isn't valid */
         continue;

      /* create object id reflecting this arp table entry's IP & iface */

      /* copy IP address into current. */
      cp = (u_char*)&atp->t_pro_addr;
      for (i = vp->namelen; i < vp->namelen+4; i++) /* current[11]-current[14] */
         current[i] = *cp++;

      /* set interface index in objId */
      current[vp->namelen-1] = (oid)((u_long)if_netnumber(atp->net) + 1);

      if (oper)   /* operation is SET or GET */
      {
         if (compare(current, IF_OIDLEN-1, name, *length) == 0)
         {   MEMCPY((char *)lowest, (char *)current, (vp->namelen+4) * sizeof(oid));
            lowarp = atp;
            break;   /* no need to search further */
         }
      }
      else     /* caller wants closest match */
      {
         /* if new one is greater than input and closer to input than
          * previous lowest, save this one as the "next" one. */
         if ((compare(current, IF_OIDLEN-1, name, *length) > 0) &&
             (!lowarp || (compare(current, IF_OIDLEN-1, lowest, IF_OIDLEN-1) < 0)))
         {
            MEMCPY((char *)lowest, (char *)current, (vp->namelen+4) * sizeof(oid));
            lowarp = atp;
         }
      }

   }   /* end for at_mib loop */

   if (!lowarp) return(NULL); /* no match */

   MEMCPY((char *)name, (char *)lowest, (vp->namelen+4) * sizeof(oid));
   *length = (vp->namelen+4);
   *var_len = sizeof long_return;   /* default return length */

   switch (vp->magic)
   {
   case IPNETTOMEDIAIFINDEX:
      long_return =  (unsigned   long)lowest[10];
      return (u_char *)&long_return;
   case IPNETTOMEDIAPHYSADDRESS:
      MEMCPY((char *)return_buf, (char *)lowarp->t_phy_addr, 6);
      *var_len = 6;
      return (u_char *)return_buf;
   case IPNETTOMEDIANETADDRESS:
      *var_len = 4;
      return (u_char *)&lowarp->t_pro_addr;
   case IPNETTOMEDIATYPE:
      long_return =  3; /* type 3 == 'dynamic'; see rfc1213 */
      return (u_char *)&long_return;
      default:
      SNMPERROR("var_AtEntry: bad magic number");
   }
   return NULL;
}



/* FUNCTION: var_icmp()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_icmp(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   u_char * cp;   /* return pointer */

   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   cp = (u_char*)&icmp_mib;
   return(cp + vp->magic);
}

extern   struct tcp_mib tcpmib;


/* FUNCTION: var_tcp()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_tcp(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
#ifdef INCLUDE_TCP
   u_char * cp;

   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   cp = (u_char*)&tcpmib;
   return(cp + vp->magic);

#else /* no TCP */
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);

   return NULL;   /* default FAIL return. */
#endif   /* INCLUDE_TCP */
}



/* storage for IPv4 address */
ip_addr  v4addr_return;

/* data structure to map InterNiche TCP state identifiers (TCPS_xxx)
 * to those specified in the description for tcpConnState in RFC 1213.
 * This table is indexed by the InterNiche TCP state identifier.
 */
const static u_char tcp_state_map[] =
{
   1,  /* closed(1) */
   2,  /* listen(2) */
   3,  /* synSent(3) */
   4,  /* synReceived(4) */
   5,  /* established(5) */
   8,  /* closeWait(8) */
   6,  /* finWait1(6) */
   10, /* closing(10) */
   9,  /* lastAck(9) */
   7,  /* finWait2(7) */
   11, /* timeWait(11) */
};

/* FUNCTION: IPv4_2_OID()
 *
 * This function an IPv4 address in network byte order into its corresponding
 * OID.
 *
 * PARAM1: ip_addr            IPv4 address
 * PARAM2: oid *              Pointer to storage for the corresponding OID
 *                            elements
 * RETURNS: None
 */
static void
IPv4_2_OID(ip_addr a4, oid *oidp)
{
   oidp[0] = a4 & 0x000000ff;
   oidp[1] = (a4 & 0x0000ff00) >> 8;
   oidp[2] = (a4 & 0x00ff0000) >> 16;
   oidp[3] = (a4 & 0xff000000) >> 24;
}



/* FUNCTION: COMPARE_CONNS()
 *
 * This function compares two connection structures.  It is only used
 * for TCP connections.  All host address and port parameters are in
 * network byte order.
 *
 * PARAM1: struct conn *      Pointer to connection structure #1
 * PARAM2: struct conn *      Pointer to connection structure #2
 *
 * RETURNS: TRUE, if the structures are identical; FALSE, otherwise.
 */
static bool_t
COMPARE_CONNS(struct conn *cp1, struct conn *cp2)
{
   if (cp1->laddr == cp2->laddr &&
       cp1->lport == cp2->lport &&
       cp1->raddr == cp2->raddr &&
       cp1->rport == cp2->rport)
      return (TRUE);
   else
      return (FALSE);
}



/* FUNCTION: oidv2conn()
 *
 * This function extracts the local address, local port number, remote
 * address, and remote port number from the OID, and copies them into
 * the connection structure provided by the caller.  If the OID does not
 * contain all of the required elements, the remaining elements are
 * initialized to zero.  If the OID contains more elements than required
 * (20), the trailing elements are not used.  This function is only used
 * for TCP connections.
 *
 * PARAM1: oid *              Pointer to storage for the OID
 * PARAM2: int                Number of elements in OID
 * PARAM3: struct conn *      Pointer to connection structure
 *
 * RETURN: This function returns 0 if it was able to extract the required
 * information successfully; otherwise, it returns -1.
 */
int
oidv2conn(oid *oidp, int count, struct conn *connp)
{
   oid loid[TCPCONN_OID_IDX_LEN];
   int num2copy;
   u_char *cp;
   int i;
   ip_addr laddr, raddr;
   u_short lport, rport;

   if (count < TCPCONN_OID_BASE_LEN)
      return (-1);

   /* caller-provided OID is at least 10 elements long */
#if 1 /* INICHE_TCPIP_ITGR, see 1239125 */
   num2copy = MIN(count - TCPCONN_OID_BASE_LEN, TCPCONN_OID_IDX_LEN); /* replaced min by MIN */
#else
   num2copy = min(count - TCPCONN_OID_BASE_LEN, TCPCONN_OID_IDX_LEN);
#endif

   MEMCPY(&loid[0], &oidp[TCPCONN_OID_BASE_LEN], num2copy * sizeof(oid));
   MEMSET(&loid[num2copy], 0, (TCPCONN_OID_IDX_LEN - num2copy) * sizeof(oid));

   /* extract local address, local port, remote address, and remote port
    * from received OID
    */
   cp = (u_char *)&laddr;
   for (i = TCPCONN_OID_LADDR_OFF; i < sizeof(ip_addr); ++i, ++cp)
      *cp = (u_char)loid[i];

   lport = (u_short)loid[TCPCONN_OID_LPORT_OFF];

   cp = (u_char *)&raddr;
   for (i = TCPCONN_OID_RADDR_OFF; i < TCPCONN_OID_RADDR_OFF + sizeof(ip_addr); ++i, ++cp)
      *cp = (u_char)loid[i];

   rport = (u_short)loid[TCPCONN_OID_RPORT_OFF];

   /* addresses are in network byte order, port numbers are in host byte order */
   connp->laddr = laddr;
   connp->lport = htons(lport);
   connp->raddr = raddr;
   connp->rport = htons(rport);

   return (0);
}



/* stores information about TCP FSM instance being processed for deletion */
struct tcpsock tcp_so;

/* FUNCTION: var_tcpConnEntry_get()
 *
 * This function processes a GET request for an object in an entry in the
 * tcpConnTable.
 *
 * PARAM1: struct conn *      Connection data structure containing values for
 *                            the local address, local port, remote address,
 *                            and remote port (that have been extracted from
 *                            the received GET request)
 * PARAM2: int                object identifier (e.g., TCPCONNSTATE, extracted
 *                            from the OID for the object being queried)
 * PARAM3: int *              Pointer to storage for the length of object
 *                            queried in GET request (filled in by this
 *                            function)
 *
 * RETURNS: If successful, this function returns a pointer to storage
 * containing the value of the desired object.  Otherwise, it returns
 * NULL.
 */
u_char *
var_tcpConnEntry_get(struct conn *connp, int obj, int *lenp)
{
   bool_t found;

   found = tcptbl_search(connp, obj, NULL);
   if (found == FALSE)
      return (NULL);

   switch (obj)
   {
      case TCPCONNSTATE:
      if (connp->state < sizeof(tcp_state_map)/sizeof(u_char))
      {
         long_return = tcp_state_map[connp->state];
         *lenp = sizeof(long);
         return ((u_char *)&long_return);
      }
      else
         return (NULL);

      case TCPCONNLOCALADDRESS:
      /* RFC 1155, section 3.2.3.2 */
      v4addr_return = connp->laddr;
      *lenp = sizeof(ip_addr);
      return ((u_char *)&v4addr_return);

      case TCPCONNLOCALPORT:
      long_return = ntohs(connp->lport);
      *lenp = sizeof(long);
      return ((u_char *)&long_return);

      case TCPCONNREMADDRESS:
      v4addr_return = connp->raddr;
      *lenp = sizeof(ip_addr);
      return ((u_char *)&v4addr_return);

      case TCPCONNREMPORT:
      long_return = ntohs(connp->rport);
      *lenp = sizeof(long);
      return ((u_char *)&long_return);

      default:
      return (NULL);
   }
}



/* FUNCTION: set_tcpConnState()
 *
 * This function is invoked to set the tcpConnState object in the tcpConnTable
 * to deleteTCB (12).  This results in a termination of the TCP connection.
 *
 * PARAM1: u_char *           Pointer to start of ASN.1 TLV for tcpConnState
 * PARAM2: u_char             ASN.1 type of tcpConnState (INTEGER)
 * PARAM3: int                Length of the V (value) portion for tcpConnState
 * PARAM4: u_char *           Pointer to object being set (returned by
 *                            var_tcpConnEntry_set())
 * PARAM5: int                Length of object being set (set by
 *                            var_tcpConnEntry_set())
 *
 * RETURNS: If the set was completed successfully, this function returns
 * SNMP_ERR_NOERROR; otherwise, it returns SNMP_ERR_BADVALUE.
 */
int
set_tcpConnState(u_char *var_val, u_char var_val_type, int var_val_len,
                 u_char *statP, int statLen)
{
   u_char *datap;
   int rc;
   long tcp_state;
   u_char type;
   unsigned tlv_len;

   USE_ARG(var_val_type);
   USE_ARG(var_val_len);
   USE_ARG(statLen);

   ((struct tcpsock *)statP)->state = TCPCONN_DELETE_TCB;
   tlv_len = 0xFFFF; /* arbitrarily chosen (not known prior to parsing) */
   datap = asn_parse_int(var_val, &tlv_len, &type, &tcp_state, sizeof(tcp_state));
   if (!datap || tcp_state != TCPCONN_DELETE_TCB)
      return (SNMP_ERR_BADVALUE);

   rc = tcptbl_killconn(((struct tcpsock *)statP)->sp);
   if (rc != SUCCESS)
      return (SNMP_ERR_BADVALUE);

   return (SNMP_ERR_NOERROR);
}



/* FUNCTION: var_tcpConnEntry_set()
 *
 * This function processes a SET request for the tcpConnState object in an
 * entry in the tcpConnTable.
 *
 * PARAM1: struct conn *      Connection data structure containing values for
 *                            the local address, local port, remote address,
 *                            and remote port (that have been extracted from
 *                            the received SET request)
 * PARAM2: int                object identifier (e.g., TCPCONNSTATE, extracted
 *                            from the OID for the object being queried)
 * PARAM3: int *              Pointer to storage for the length of object
 *                            queried in SET request (filled in by this
 *                            function)
 * PARAM4: struct variable *  Pointer to corresponding entry (for tcpConnState)
 *                            in the variables[] array
 * PARAM5: oid *              Pointer to storage for elements in OID (of
 *                            object being set)
 * PARAM6: int *              Pointer to storage containing number of elements
 *                            in OID of object being set
 *
 * RETURNS: If successful, this function returns a pointer to storage
 * containing the value of the desired object.  (Please note that the storage
 * is local to the SNMP module.)  Otherwise, it returns NULL.
 */
u_char *
var_tcpConnEntry_set(struct conn *connp, int obj, int *lenp,
                     struct variable *vp, oid *name, int *nlenp)
{
   bool_t found;

   if (obj != TCPCONNSTATE)
      return (NULL);

   found = tcptbl_search(connp, obj, &tcp_so.sp);
   if (found == FALSE)
      return (NULL);

   set_parms.access_method = set_tcpConnState;
   set_parms.vp = vp;
   set_parms.name = name;
   set_parms.name_len = *nlenp;
   set_parms.do_range = TRUE;
   set_parms.hi_range = TCPCONN_DELETE_TCB;
   set_parms.lo_range = TCPCONN_DELETE_TCB;
   *lenp = sizeof(long);

   /* return socket pointer, instead of pointer to TCP control block's
    * state variable (t_state)
    */
   return ((u_char *)&tcp_so);
}



/* FUNCTION: var_tcpConnEntry_getnext()
 *
 * This function processes a GET-NEXT request that targets an object that may
 * (or may not) reside in the tcpConnTable.
 *
 * PARAM1: struct conn *      Connection data structure containing values for
 *                            the local address, local port, remote address,
 *                            and remote port (that have been extracted from
 *                            the received GET-NEXT request)
 * PARAM2: int                object identifier (e.g., TCPCONNSTATE, extracted
 *                            from the OID for the object being queried)
 * PARAM3: int *              Pointer to storage for the length of object
 *                            queried in GET-NEXT request (filled in by this
 *                            function)
 * PARAM4: struct variable *  Pointer to corresponding entry in the
 *                            variables[] array
 * PARAM5: oid *              Pointer to storage for elements in OID (of
 *                            object being set)
 * PARAM6: int *              Pointer to storage containing number of elements
 *                            in OID of object being set
 * PARAM7: bool_t             TRUE, if OID in GET-NEXT request matches one of
 *                            objects in the tcpConnEntry data structure; FALSE,
 *                            otherwise
 *
 * RETURNS: If successful, this function returns a pointer to storage
 * containing the value of the "next" object.  Otherwise, it returns NULL.
 */
u_char *
var_tcpConnEntry_getnext(struct conn *connp, int obj, int *lenp,
                         struct variable *vp, oid *name, int *nlenp,
                         bool_t ours)
{
   int i;
   struct conn tcpcon;
   bool_t found;
   bool_t complete_oid;
   bool_t identical;

   if (!ours)
   {
      /* return information from first entry in table */
      if (obj == -1)
         obj = TCPCONNSTATE;
      found = tcptbl_find_lowest(&tcpcon, obj);
      if (found == FALSE)
         return (NULL);
      /* copy output OID */
      for (i = 0; i < vp->namelen - 1; ++i)
         name[i] = vp->name[i];
      obj = (vp->name[TCPCONN_OID_OBJTYPE_IDX] - 1) * 4;
   }
   else
   {
      if (*nlenp == TCPCONN_OID_LEN)
         complete_oid = TRUE;
      else
         complete_oid = FALSE;

      if (!complete_oid)
         oidv2conn(name, *nlenp, connp);

      /* extract last entry in table */
      found = tcptbl_find_highest(&tcpcon, obj);
      if (found == FALSE)
         return (NULL);
      identical = COMPARE_CONNS(connp, &tcpcon);
      if (!identical)
      {
         found = tcptbl_find_next_highest(connp, &tcpcon, obj);
         /* this shouldn't occur (because 'connp' is not the highest entry) */
         if (found == FALSE)
            return (NULL);
         /* copy output OID */
         for (i = 0; i < vp->namelen - 2; ++i)
            name[i] = vp->name[i];
         name[i++] = obj/4 + 1;
      }
      else
      {
         return (NULL);
      }
   }

   /* create index portion of output OID (based on connection-specific information) */
   IPv4_2_OID(tcpcon.laddr, &name[i]);
   i+= sizeof(ip_addr);
   name[i++] = ntohs(tcpcon.lport);
   IPv4_2_OID(tcpcon.raddr, &name[i]);
   i+= sizeof(ip_addr);
   name[i++] = ntohs(tcpcon.rport);
   *nlenp = i;

    switch (obj)
    {
       case TCPCONNSTATE:
       long_return = tcp_state_map[tcpcon.state];
       *lenp = sizeof(long);
       return ((u_char *)&long_return);

       case TCPCONNLOCALADDRESS:
       /* RFC 1155, section 3.2.3.2 */
       v4addr_return = tcpcon.laddr;
       *lenp = sizeof(ip_addr);
       return ((u_char *)&v4addr_return);

       case TCPCONNLOCALPORT:
       long_return = ntohs(tcpcon.lport);
       *lenp = sizeof(long);
       return ((u_char *)&long_return);

       case TCPCONNREMADDRESS:
       v4addr_return = tcpcon.raddr;
       *lenp = sizeof(ip_addr);
       return ((u_char *)&v4addr_return);

       case TCPCONNREMPORT:
       long_return = ntohs(tcpcon.rport);
       *lenp = sizeof(long);
       return ((u_char *)&long_return);

       default:
       return (NULL);
    }
}

/* FUNCTION: var_tcpConnEntry()
 *
 * This function processes a GET, GET-NEXT, or SET request that is directed to the
 * tcpConnTable.
 *
 * PARAM1: struct variable *  (IN) Pointer to corresponding entry in the
 *                            variables[] array
 * PARAM2: oid *              (IN/OUT) input OID requested; output OID found
 * PARAM3: int *              (IN/OUT) length of input or output OIDs
 * PARAM4: int                (IN) Type of operation (NEXT_OP (=0), GET_OP
 *                            (=1), or SET_OP (=-1))
 * PARAM5: int *              (OUT) length of variable
 *
 * RETURNS: This function returns NULL if the caller requests an unknown
 * operation, or if the length of the OID is not appropriate for a GET
 * request.  Otherwise, it returns the return code from the helper functions
 * that process the received GET, GET-NEXT, or SET request.
 */

u_char *
var_tcpConnEntry(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   int i;
   u_char *cp;
   ip_addr laddr, raddr;
   u_short lport, rport;
   int obj = -1;
   struct conn con;
   bool_t ours;

   if ((*length >= vp->namelen - 1) &&
        compare(name, vp->namelen - 1, &vp->name[0], vp->namelen - 1) == 0)
      ours = TRUE;
   else
      ours = FALSE;

   if (oper == GET_OP || oper == SET_OP)
      if (!ours || *length != TCPCONN_OID_LEN)
         return (NULL);

   /* extract and validate the object number being requested in GET or SET request */
   if (ours)
   {
      obj = (int)name[TCPCONN_OID_OBJTYPE_IDX];
      if (obj < TCPCONN_STATE_ID || obj > TCPCONN_RPORT_ID)
         return (NULL);
      /* convert (ones-based) object number to corresponding magic number */
      --obj;
      obj *= 4;

      if (*length == TCPCONN_OID_LEN)
      {
         /* extract LA, LP, RA, and RP from received OID */
         cp = (u_char *)&laddr;
         for (i = TCPCONN_OID_LADDR_IDX; i < TCPCONN_OID_LPORT_IDX; ++i, ++cp)
            *cp = (u_char)name[i];

         lport = (u_short)name[TCPCONN_OID_LPORT_IDX];

         cp = (u_char *)&raddr;
         for (i = TCPCONN_OID_RADDR_IDX; i < TCPCONN_OID_RPORT_IDX; ++i, ++cp)
            *cp = (u_char)name[i];

         rport = (u_short)name[TCPCONN_OID_RPORT_IDX];

         /* addresses are in network byte order, port numbers are in host byte order */
         con.laddr = laddr;
         con.lport = htons(lport);
         con.raddr = raddr;
         con.rport = htons(rport);
      }

      /* all components of 'con' are now in network byte order */
      switch (oper)
      {
         case GET_OP:
         return (var_tcpConnEntry_get(&con, obj, var_len));

         case SET_OP:
         return (var_tcpConnEntry_set(&con, obj, var_len, vp, name, length));

         case NEXT_OP:
         /* continue below */
         break;

         default:
         return (NULL);
      }
   }

   /* process a GET-NEXT request */
   return (var_tcpConnEntry_getnext(&con, obj, var_len, vp, name, length, ours));
}



/* FUNCTION: var_udp()
 *
 * PARAM1: struct variable *   vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int   oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_udp(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   u_char * cp;

   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   cp = (u_char*)&udp_mib;
   return(cp + vp->magic);
}

/* FUNCTION: COMPARE_CONNS_U()
 *
 * This function compares two connection structures.  It is only used
 * for UDP connections.  All host address and port parameters are in
 * network byte order.
 *
 * PARAM1: struct conn *      Pointer to connection structure #1
 * PARAM2: struct conn *      Pointer to connection structure #2
 *
 * RETURNS: TRUE, if the structures are identical; FALSE, otherwise.
 */
bool_t
COMPARE_CONNS_U(struct conn *cp1, struct conn *cp2)
{
   if (cp1->laddr == cp2->laddr &&
       cp1->lport == cp2->lport)
      return (TRUE);
   else
      return (FALSE);
}


/* FUNCTION: oidv2conn_u()
 *
 * This function extracts the local address and local port number from
 * the OID, and copies them into the connection structure provided by
 * the caller.  If the OID does not contain all of the required elements,
 * the remaining elements are initialized to zero.  If the OID contains
 * more elements than required (15), the trailing elements are not used.
 * This function is only used for UDP connections.
 *
 * PARAM1: oid *              Pointer to storage for the OID
 * PARAM2: int                Number of elements in OID
 * PARAM3: struct conn *      Pointer to connection structure
 *
 * RETURN: This function returns 0 if it was able to extract the required
 * information successfully; otherwise, it returns -1.
 */
int
oidv2conn_u(oid *oidp, int count, struct conn *connp)
{
   oid loid[10];
   int num2copy;
   u_char *cp;
   int i;
   ip_addr laddr;
   u_short lport;

   if (count < UDPCONN_OID_BASE_LEN)
      return (-1);

   /* caller-provided OID is at least 10 elements long */
#if 1 /* INICHE_TCPIP_ITGR, see 1239125 */
   num2copy = MIN(count - UDPCONN_OID_BASE_LEN, UDPCONN_OID_IDX_LEN); /* replaced min by MIN */
#else
   num2copy = min(count - UDPCONN_OID_BASE_LEN, UDPCONN_OID_IDX_LEN);
#endif

   MEMCPY(&loid[0], &oidp[UDPCONN_OID_BASE_LEN], num2copy * sizeof(oid));
   MEMSET(&loid[num2copy], 0, (UDPCONN_OID_IDX_LEN - num2copy) * sizeof(oid));

   /* extract local address and local port from received OID */
   cp = (u_char *)&laddr;
   for (i = UDPCONN_OID_LADDR_OFF; i < sizeof(ip_addr); ++i, ++cp)
      *cp = (u_char)loid[i];

   lport = (u_short)loid[UDPCONN_OID_LPORT_OFF];

   /* addresses are in network byte order, port numbers are in host byte order */
   connp->laddr = laddr;
   connp->lport = lport;

   return (0);
}


/* FUNCTION: var_udpEntry_get()
 *
 * This function processes a GET request for an object in an entry in the
 * udpTable.
 *
 * PARAM1: struct conn *      Connection data structure containing values for
 *                            the local address, local port, remote address,
 *                            and remote port (that have been extracted from
 *                            the received GET request)
 * PARAM2: int                object identifier (e.g., UDPLOCALADDRESS,
 *                            extracted from the OID for the object being
 *                            queried)
 * PARAM3: int *              Pointer to storage for the length of object
 *                            queried in GET request (filled in by this
 *                            function)
 *
 * RETURNS: If successful, this function returns a pointer to storage
 * containing the value of the desired object.  Otherwise, it returns
 * NULL.
 */
u_char *
var_udpEntry_get(struct conn *connp, int obj, int *lenp)
{
   bool_t found;

   found = udptbl_search(connp);
   if (found == FALSE)
      return (NULL);

   switch (obj)
   {
      case UDPLOCALADDRESS:
      /* RFC 1155, section 3.2.3.2 */
      v4addr_return = connp->laddr;
      *lenp = sizeof(ip_addr);
      return ((u_char *)&v4addr_return);

      case UDPLOCALPORT:
      long_return = ntohs(connp->lport);
      *lenp = sizeof(long);
      return ((u_char *)&long_return);

      default:
      return (NULL);
   }
}


/* FUNCTION: var_udpEntry_getnext()
 *
 * This function processes a GET-NEXT request that targets an object that may
 * (or may not) reside in the udpTable.
 *
 * PARAM1: struct conn *      Connection data structure containing values for
 *                            the local address, local port, remote address,
 *                            and remote port (that have been extracted from
 *                            the received GET-NEXT request)
 * PARAM2: int                object identifier (e.g., UDPLOCALADDRESS,
 *                            extracted from the OID for the object being
 *                            queried)
 * PARAM3: int *              Pointer to storage for the length of object
 *                            queried in GET-NEXT request (filled in by this
 *                            function)
 * PARAM4: struct variable *  Pointer to corresponding entry in the
 *                            variables[] array
 * PARAM5: oid *              Pointer to storage for elements in OID (of
 *                            object being set)
 * PARAM6: int *              Pointer to storage containing number of elements
 *                            in OID of object being set
 * PARAM7: bool_t             TRUE, if OID in GET-NEXT request matches one of
 *                            objects in the udpEntry data structure; FALSE,
 *                            otherwise
 *
 * RETURNS:
 */
u_char *
var_udpEntry_getnext(struct conn *connp, int obj, int *lenp, struct variable *vp, oid *name, int *nlenp, bool_t ours)
{
   int i;
   struct conn udpcon;
   bool_t found;
   bool_t complete_oid;
   bool_t identical;

   if (!ours)
   {
      /* return information from first entry in table */
      if (obj == -1)
         obj = UDPLOCALADDRESS;
      found = udptbl_find_lowest(&udpcon);
      if (found == FALSE)
         return (NULL);
      /* copy output OID */
      for (i = 0; i < vp->namelen - 1; ++i)
         name[i] = vp->name[i];
      obj = (vp->name[UDPCONN_OID_OBJTYPE_IDX] - 1) * 4;
   }
   else
   {
      if (*nlenp == UDPCONN_OID_LEN)
         complete_oid = TRUE;
      else
         complete_oid = FALSE;

      if (!complete_oid)
         oidv2conn_u(name, *nlenp, connp);

      /* extract last entry in table */
      found = udptbl_find_highest(&udpcon);
      if (found == FALSE)
         return (NULL);
      identical = COMPARE_CONNS_U(connp, &udpcon);
      if (!identical)
      {
         found = udptbl_find_next_highest(connp, &udpcon);
         /* this shouldn't occur (because 'connp' is not the highest entry) */
         if (found == FALSE)
            return (NULL);
         /* copy output OID */
         for (i = 0; i < vp->namelen - 2; ++i)
            name[i] = vp->name[i];
         name[i++] = obj/4 + 1;
      }
      else
         return (NULL);
   }

   /* create index portion of output OID (based on connection-specific information) */
   IPv4_2_OID(udpcon.laddr, &name[i]);
   i+= sizeof(ip_addr);
   name[i++] = ntohs(udpcon.lport);
   *nlenp = i;

    switch (obj)
    {
       case UDPLOCALADDRESS:
       v4addr_return = udpcon.laddr;
       *lenp = sizeof(ip_addr);
       return ((u_char *)&v4addr_return);

       case UDPLOCALPORT:
       long_return = ntohs(udpcon.lport);
       *lenp = sizeof(long);
       return ((u_char *)&long_return);

       default:
       return (NULL);
    }
}

/* udp connection table - NetPort stack has a hardcoded echo listen
 * connection, an optional imbedded snmp agent, plus a real UDP
 * connection table. For now, just hardcode it as two listens - 7
 * (echo) & 161 (snmp). 10/23/93 DOS TSR DEMO, -JB-
 */


/* FUNCTION: var_udpEntry()
 *
 * This function processes a GET, GET-NEXT, or SET request that is directed
 * to the udpTable.
 *
 * PARAM1: struct variable *  (IN) Pointer to corresponding entry in the
 *                            variables[] array
 * PARAM2: oid *              (IN/OUT) input OID requested; output OID found
 * PARAM3: int *              (IN/OUT) length of input or output OIDs
 * PARAM4: int                (IN) Type of operation (NEXT_OP (=0), GET_OP
 *                            (=1), or SET_OP (=-1))
 * PARAM5: int *              (OUT) length of variable
 *
 * RETURNS: This function returns NULL if the caller requests an unknown
 * operation, or if the length of the OID is not appropriate for a GET
 * request.  Otherwise, it returns the return code from the helper functions
 * that process the received GET or GET-NEXT request.
 */

u_char *
var_udpEntry(
   struct variable *    vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int   oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   int i;
   u_char *cp;
   ip_addr laddr;
   u_short lport;
   int obj = -1;
   struct conn con;
   bool_t ours;

   if ((*length >= vp->namelen - 1) &&
        compare(name, vp->namelen - 1, &vp->name[0], vp->namelen - 1) == 0)
      ours = TRUE;
   else
      ours = FALSE;

   if (oper == GET_OP)
      if (!ours || *length != UDPCONN_OID_LEN)
         return (NULL);

   /* extract and validate the object number being requested in GET or SET request */
   if (ours)
   {
      obj = (int)name[UDPCONN_OID_OBJTYPE_IDX];
      if (obj < UDPCONN_LADDR_ID || obj > UDPCONN_LPORT_ID)
         return (NULL);
      /* convert object number to corresponding magic number */
      --obj;
      obj *= 4;

      if (*length == UDPCONN_OID_LEN)
      {
         /* extract LA and LP from received OID */
         cp = (u_char *)&laddr;
         for (i = UDPCONN_OID_LADDR_IDX; i < UDPCONN_OID_LPORT_IDX; ++i, ++cp)
            *cp = (u_char)name[i];

         lport = (u_short)name[UDPCONN_OID_LPORT_IDX];

         /* address is in network byte order, port number is in host byte order */
         con.laddr = laddr;
         con.lport = htons(lport);
      }

      /* all components of 'con' are in network byte order */
      switch (oper)
      {
         case GET_OP:
         return (var_udpEntry_get(&con, obj, var_len));

         case SET_OP:
         return (NULL);

         case NEXT_OP:
         /* process a GET-NEXT request */
         break;

         default:
         return (NULL);
      }
   }

   return (var_udpEntry_getnext(&con, obj, var_len, vp, name, length, ours));
}



/* FUNCTION: var_egp()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_egp(
   struct variable * vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{

   /* No EGP support anymore */
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);

   return NULL;   /* default FAIL return.*/
}



/* FUNCTION: var_egpNeighEntry()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_egpNeighEntry(
   struct variable * vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
   /* No EGP support anymore */
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);

   return NULL;   /* default FAIL return.*/
}



/* FUNCTION: var_snmp()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid *   name
 * PARAM3: int *   length
 * PARAM4: int      oper
 * PARAM5: int     var_len
 *
 * RETURNS:
 */

u_char *
var_snmp(
   struct variable * vp,   /* IN - pointer to variables[] entry */
   oid *    name,       /* IN/OUT - input name requested; output name found */
   int *    length,  /* IN/OUT - length of input & output oids */
   int      oper,    /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *    var_len) /* OUT - length of variable, or 0 if function */
{
#ifdef MIB_COUNTERS

   u_char * cp;

   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   cp = (u_char*)&SnmpMib;

   return(cp + vp->magic);
#else
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);
   return NULL ;
#endif   /* MIB_COUNTERS */

}

/* FUNCTION: var_snmpTrap()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid *  name
 * PARAM3: int *  length
 * PARAM4: int    oper
 * PARAM5: int    var_len
 *
 * The objects of this group are "accessible-for-notify".
 * Hence no need to implement this.
 *
 * RETURNS:
 */

u_char *
var_snmpTrap(
   struct variable * vp, /* IN - pointer to variables[] entry */
   oid *   name,         /* IN/OUT - input name requested; output name found */
   int *   length,       /* IN/OUT - length of input & output oids */
   int   oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *   var_len)      /* OUT - length of variable, or 0 if function */
{
   USE_ARG(vp);
   USE_ARG(name);
   USE_ARG(length);
   USE_ARG(oper);
   USE_ARG(var_len);
   return NULL;   /* default FAIL return.*/
}

#ifdef SNMPSETSERIALNO   /* support only if RFC3418 is supported */

/* FUNCTION: var_snmpSet()
 *
 * PARAM1: struct variable * vp
 * PARAM2: oid * name
 * PARAM3: int * length
 * PARAM4: int   oper
 * PARAM5: int   var_len
 *
 * This group needs to be implemented so that multiple SNMP Managers
 * can co-ordinate their SET operations.
 *
 * RETURNS:
 */

static long serial_num=0;  /* used only by this function */

u_char *
var_snmpSet(
   struct variable * vp, /* IN - pointer to variables[] entry */
   oid *   name,         /* IN/OUT - input name requested; output name found */
   int *   length,       /* IN/OUT - length of input & output oids */
   int   oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
   int *   var_len)      /* OUT - length of variable, or 0 if function */
{
   if (oper && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
      return NULL;

   MEMCPY(name, vp->name, (int)vp->namelen * sizeof(oid));
   *length = vp->namelen;
   *var_len = sizeof(long);   /* default length */

   switch (vp->magic)
   {
   case SNMPSETSERIALNO:
      if ( oper == SET_OP )
         set_parms.access_method = setTestAndIncr;
      else
         serial_num++;
      return (u_char*)&serial_num;
   case SYSOBJECTID:
   default:
      SNMPERROR("var_system: Unknown magic number");
   }
   return NULL;   /* default FAIL return. */
}

#endif /* SNMPSETSERIALNO */


#endif /* INICHE_TCPIP */
#endif /* INCLUDE_SNMP */
