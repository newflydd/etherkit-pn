/*
    C code file Generated by InterNiche Technologies MIB Compiler
    Copyright 1993-1999 by InterNiche Technologies
*/
/*****************************************************************************/
/** Copyright 1990-96 by NetPort Software. All rights reserved.              */
/** Copyright 1996-2004 By InterNiche Technologies Inc. All rights reserved. */
/*  Copyright (C) 2020 Siemens Aktiengesellschaft. All rights reserved.      */
/*****************************************************************************/
/*  This program is protected by German copyright law and international      */
/*  treaties. The use of this software including but not limited to its      */
/*  Source Code is subject to restrictions as agreed in the license          */
/*  agreement between you and Siemens.                                       */
/*  Copying or distribution is not allowed unless expressly permitted        */
/*  according to your license agreement with Siemens.                        */
/*****************************************************************************/
/*                                                                           */
/*  P r o j e c t         &P: PROFINET IO Runtime Software              :P&  */
/*                                                                           */
/*  P a c k a g e         &W: PROFINET IO Runtime Software              :W&  */
/*                                                                           */
/*  C o m p o n e n t     &C: OHA (Option HAndler)                      :C&  */
/*                                                                           */
/*  F i l e               &F: oha_mrpr.c                                :F&  */
/*                                                                           */
/*  V e r s i o n         &V: BC_PNRUN_P07.02.00.00_00.02.00.20         :V&  */
/*                                                                           */
/*  D a t e  (YYYY-MM-DD) &D: 2020-09-21                                :D&  */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  D e s c r i p t i o n:  OHA SNMP-Agent functions                         */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  H i s t o r y :                                                          */
/*  ________________________________________________________________________ */
/*                                                                           */
/*  Date        Who   What                                                   */
/*  20.07.04    VE    initial version.                                       */
/*****************************************************************************/

#define LTRC_ACT_MODUL_ID 49
#define OHA_MODULE_ID     LTRC_ACT_MODUL_ID /* OHA_MODULE_ID_OHA_MRPR */

/*===========================================================================*/
/*                                 includes                                  */
/*===========================================================================*/

#include "oha_inc.h"            /* OHA headerfiles  */
#include "oha_int.h"            /* internal header  */

/* BTRACE-IF */
OHA_FILE_SYSTEM_EXTENSION(OHA_MODULE_ID)

#ifndef OHA_CFG_NO_MRP
#ifndef OHA_CFG_NO_MRP_MIB

#include "oha_asn1.h"
#include "oha_agnt.h"           /* OHA-Agent header */
#include "oha_snmp.h"           /* SNMP header      */

#include "oha_mibs.h"

/*===========================================================================*/
/*                                global Variables                           */
/*===========================================================================*/

/* SPLINT: Initializer does not define all elements of a declared array.     */
/*     Initializer block for oha_mrp_variables[0].name                       */
/*     has 9 elements, but declared as unsigned long int [20],...            */

static struct snmp_variable oha_mrp_variables[] =
{
	{{1,0,62439,1,1,1,1, 2,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_OCTET_STR, MRPDOMAINID, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 3,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_OCTET_STR, MRPDOMAINNAME, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 4,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINADMINROLE, OHA_SNMP_RWRITE, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 5,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINOPERROLE, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 6,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINRINGPORT1, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 7,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINRINGPORT1STATE, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 8,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINRINGPORT2, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1, 9,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINRINGPORT2STATE, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,10,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, /* ASN_BIT_STR */ ASN_OCTET_STR, MRPDOMAINSTATE, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,11,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, /* ASN_BIT_STR */ ASN_OCTET_STR, MRPDOMAINERROR, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,12,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINBLOCKED, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,13,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, OHA_SNMP_UNSIGNED32, MRPDOMAINVLANID, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,14,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINMANAGERPRIORITY, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,15,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, OHA_SNMP_COUNTER, MRPDOMAINRINGOPENCOUNT, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,16,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, OHA_SNMP_TIMETICKS, MRPDOMAINLASTRINGOPENCHANGE, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,17,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, OHA_SNMP_UNSIGNED32, MRPDOMAINROUNDTRIPDELAYMAX, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,18,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, OHA_SNMP_UNSIGNED32, MRPDOMAINROUNDTRIPDELAYMIN, OHA_SNMP_RONLY, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,19,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINRESETROUNDTRIPDELAYS, OHA_SNMP_RWRITE, var_mrpDomainEntry },
	{{1,0,62439,1,1,1,1,20,0xFF,0, 0,0,0,0,0,0,0,0,0,0}, 9, ASN_INTEGER, MRPDOMAINMRMREACTONLINKCHANGE, OHA_SNMP_RONLY, var_mrpDomainEntry },
};

/* status to read from MRP */
static OHA_MRP_STATS_INFO_TYPE oha_mrp_stats_info; /* AP01479100: Wrong indexing of 2 dimensional array */

/*===========================================================================*/
/*                                functions                                  */
/*===========================================================================*/

/* FUNCTION: oha_mrp_get_if_id()
 *
 * PARAM1:   mrpDomainNumber (1...n)
 *
 * RETURNS:  if_id (1...OHA_CFG_MAX_NICS), instance_id (1...EDD_CFG_MAX_MRP_INSTANCE_CNT)
 */
static LSA_UINT oha_mrp_get_if_id(LSA_UINT mrpDomainNumber, LSA_UINT *instance_id)
{
    LSA_UINT16 domain_number;
    LSA_UINT16 inter_face;

    OHA_ASSERT(mrpDomainNumber != 0);

    for (inter_face = 1, domain_number = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(inter_face);
        if (OHA_IS_NOT_NULL(pDB))
        {
            LSA_UINT16 DomainIndex;

            for (DomainIndex = 0; domain_number <= mrpDomainNumber &&
                 DomainIndex < pDB->MaxMRP_Instances; domain_number++, DomainIndex++)
            {
                if (domain_number == mrpDomainNumber)
                {
                    if (OHA_IS_NOT_NULL(instance_id))
                    {
                        *instance_id = DomainIndex + 1;
                    }
                    OHA_FUNCTION_TRACE_02(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_mrp_get_if_id(IfID: 0x%X, DomainIndex: 0x%X)", inter_face, (DomainIndex + 1));
                    return(inter_face);
                }
            }
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_mrp_get_if_id()");
    return(0);
}

/* FUNCTION: oha_mrp_count_if_domains()
 *
 * PARAM1:
 *
 * RETURNS:  number of all domains (all interfaces)
 */

static LSA_UINT16 oha_mrp_count_if_domains(void)
{
    LSA_UINT32 domains = 0;
    LSA_UINT16 i;

    for (i = 1; i <= OHA_CFG_MAX_NICS; i++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(i);
        if (OHA_IS_NOT_NULL(pDB))
        {
            domains += pDB->MaxMRP_Instances;
        }
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_mrp_count_if_domains(num:  0x%X)", domains);
    return (LSA_UINT16)domains;
}

/* FUNCTION: oha_mrp_get_num_variables()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_INT oha_mrp_get_num_variables(void)
{
    LSA_INT num = sizeof(oha_mrp_variables)/sizeof(struct snmp_variable);

    /* OHA_MEMSET(&oha_mrp_stats_info, 0, sizeof(oha_mrp_stats_info)); */  /* AP01388134: no reset by getStatPtr()! */

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_mrp_get_num_variables(num:  0x%X)", num);
    return num;
}

/* FUNCTION: oha_mrp_get_variables_arr()
 *
 * PARAM1: void
 *
 * RETURNS:
 */

/* Borland compiler gives "fixup error" when variables[] is used in snmp.c
 * So, we will use get_variables_arr() to access variables[].
 */

#ifdef __BORLANDC__
struct snmp_variable * _loadds oha_mrp_get_variables_arr(void)
#else
struct snmp_variable *  oha_mrp_get_variables_arr(void)
#endif
{
    return   oha_mrp_variables;
}

/* FUNCTION: oha_snmp_delete_mrp_statistics()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_VOID oha_snmp_delete_mrp_statistics(LSA_VOID)
{
    OHA_MEMSET(&oha_mrp_stats_info, 0, sizeof(oha_mrp_stats_info));
    return;
}

/* FUNCTION: oha_snmp_set_RoundTripDelays()
 *
 * PARAM1: u_char  *var_val
 * PARAM2: u_char  var_val_type
 * PARAM3: int     var_val_len
 * PARAM4: OHA_OID *name
 * PARAM5: unsigned *namelen
 *
 * Address Translation table add entry to OHA-DataBase routine.
 *
 * RETURNS:
 * returns an snmp error from oha_usr.h (0 == no error)
 */
static LSA_INT oha_snmp_set_RoundTripDelays(LSA_UINT16 orginator, /* user or snmp manager */
									 U_CHAR	* var_val,    /* pointer to set value */
									 U_CHAR	var_val_type, /* snmp type of set value */
								     LSA_INT  var_val_len,  /* length of set value */
								     OHA_OID *   name,     /* matched name of var  */
								     unsigned namelen)  /* number of sub-ids in name */
{
	OHA_HDB_MRP_PTR_TYPE pMrpHDB;
	LSA_INT snmp_error = OHA_SNMP_ERR_NOERROR;
	unsigned iface;      /* interface from ObjectId index */
	LSA_INT32  RoundTripDelays = 0;
	LSA_UINT32 domain;
    unsigned   instance_id = 0;

    OHA_FUNCTION_TRACE_06(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : oha_snmp_set_RoundTripDelays(orginator: 0x%X, var_val: 0x%X, var_val_type 0x%X, var_val_len: 0x%X, name: 0x%X, namelen: 0x%X)",
                          orginator, var_val, var_val_type, var_val_len, name, namelen);

	OHA_ASSERT(namelen >= 6);
	if(namelen < 9)
	{
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_NOTE, "OUT: oha_snmp_set_RoundTripDelays(OidLen: 0x%X) - no such ObjectID for MRP", namelen);
		snmp_error = OHA_SNMP_ERR_NOSUCHNAME;
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_set_RoundTripDelays(snmp_error: 0x%X)", snmp_error);
		return snmp_error;
	}

    OHA_ASSERT_NULL_PTR(name);
	domain = name[8];

    iface = oha_mrp_get_if_id(domain, &instance_id);  /* extract interface number */

	pMrpHDB = OHA_MRPGetHandleByIndex(iface);
	if (OHA_IS_NULL(pMrpHDB))
	{
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_NOTE, "OUT: oha_snmp_set_RoundTripDelays(If: 0x%X) - no such interface for MRP", iface);
		snmp_error = OHA_SNMP_ERR_NOSUCHNAME;
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_set_RoundTripDelays(snmp_error: 0x%X)", snmp_error);
		return snmp_error;
	}
	if(instance_id < 1 || instance_id > EDD_CFG_MAX_MRP_INSTANCE_CNT)
	{
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_NOTE, "OUT: oha_snmp_set_RoundTripDelays(If: 0x%X) - no such instance_id for MRP", instance_id);
		snmp_error = OHA_SNMP_ERR_NOSUCHNAME;
		OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_set_RoundTripDelays(snmp_error: 0x%X)", snmp_error);
		return snmp_error;
	}

	/* get the value for the request */
	if(orginator == OHA_HANDLE_TYPE_USER) /* user request "ControlOid" active ? */
	{
		/* oha_setVariable() for future use */
		snmp_error = oha_parse_int(var_val, (unsigned)var_val_len, var_val_type, &RoundTripDelays, sizeof(LSA_INT32));
	}
	else if(orginator == OHA_HANDLE_TYPE_SOCK)	/* snmp "manager" active */
	{
        snmp_error = oha_snmp_setVariable(var_val, var_val_type,  (U_CHAR *)&RoundTripDelays, sizeof(RoundTripDelays));
        OHA_SNMP_LOGOID(oha_sidbuf, var_name, var_name_len, snmp_error,
                        var_val, var_val_type);
	}
	else
	{
		OHA_FATAL(OHA_FATAL_ERR_INCONSISTENZ);
	}

	if(snmp_error == OHA_SNMP_ERR_NOERROR)	/* write to OHA-DB */
	{
		pMrpHDB->MrpSetStatus[instance_id-1].domainResetRoundTripDelays = (LSA_UINT32)RoundTripDelays;
	}

	OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_set_RoundTripDelays(snmp_error: 0x%X)", snmp_error);
	return snmp_error;
}

/* FUNCTION: oha_snmp_set_DomainAdminRole()
 *
 * PARAM1: u_char  *var_val
 * PARAM2: u_char  var_val_type
 * PARAM3: int     var_val_len
 * PARAM4: OHA_OID *name
 * PARAM5: unsigned *namelen
 *
 * Address Translation table add entry to OHA-DataBase routine.
 *
 * RETURNS:
 * returns the snmp error oha_snmp_set_DomainAdminRole
 */
static LSA_INT oha_snmp_set_DomainAdminRole(LSA_UINT16 orginator, /* user or snmp manager */
									 U_CHAR	* var_val,    /* pointer to set value */
									 U_CHAR	var_val_type, /* snmp type of set value */
								     LSA_INT  var_val_len,  /* length of set value */
								     OHA_OID *   name,     /* matched name of var  */
								     unsigned namelen)  /* number of sub-ids in name */
{
	LSA_INT snmp_error = OHA_SNMP_ERR_BADVALUE;

    OHA_FUNCTION_TRACE_06(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : oha_snmp_set_DomainAdminRole(orginator: 0x%X, var_val: 0x%X, var_val_type 0x%X, var_val_len: 0x%X, name: 0x%X, namelen: 0x%X)",
                          orginator, var_val, var_val_type, var_val_len, name, namelen);

	OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_set_DomainAdminRole(snmp_error: 0x%X)", snmp_error);
	return snmp_error;
}


U_CHAR *
var_mrpDomainEntry(
	struct snmp_variable * vp,	/* IN - pointer to variables[] entry */
	OHA_OID *	name,		/* IN/OUT - input name requested; output name found */
	LSA_INT *	length,		/* IN/OUT - length of input & output oids */
	LSA_INT	oper,		/* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
	LSA_INT *	var_len)	/* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, domain;
    unsigned   instance_id = 0;
	LSA_UINT16 NICId;
    static LSA_INT32 long_return =  0L;
    static LSA_UINT8 byte_return = 0;
	OHA_HDB_MRP_PTR_TYPE   pHDBMrp;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
	LSA_UINT16 RingPort_Id1;
	LSA_UINT16 RingPort_Id2;
	LSA_UINT16 Instance_Id;
    LSA_UINT16 DomainCnt;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_mrpDomainEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    DomainCnt = oha_mrp_count_if_domains();
    if (DomainCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_mrpDomainEntry() - no domain");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[8] = 0;  /* init. (invalid) domain */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" domain */
    /* The table controls selection of MRP domain */
    for (domain = 1; domain <= DomainCnt; domain++)
    {
        int   result;
        newname[8] = domain; /* AP01355079: SNMP.req fails in case of n-If and n rings */
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (domain > DomainCnt)  /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_mrpDomainEntry() - no more domain");
        return(LSA_NULL);
    }

    inter_face = oha_mrp_get_if_id(domain, &instance_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(instance_id && (instance_id <= EDD_CFG_MAX_MRP_INSTANCE_CNT));

    if (oper == SET_OP)
	{
        oha_set_parms.do_range = LSA_TRUE;  /* force range checking on sets */

        switch (vp->magic)
        {
            case MRPDOMAINADMINROLE:
                oha_set_parms.hi_range = 2; /* MRP_CAPABILITY_ROLE_OFF */
                oha_set_parms.lo_range = 0; /* MRP_CAPABILITY_ROLE_MGR */
                oha_set_parms.access_method = oha_snmp_set_DomainAdminRole;
            break;
            case MRPDOMAINRESETROUNDTRIPDELAYS:
                oha_set_parms.hi_range = 1;
                oha_set_parms.lo_range = 1;
                oha_set_parms.access_method = oha_snmp_set_RoundTripDelays;
            break;
            default:
                oha_set_parms.do_range = LSA_FALSE;
            break;
		}
	}

	/* mrpDomainIndex doesn't represent the inter_face anymore */
	/* we have'nt only max. one domain per interface anymore   */
	pHDBMrp = OHA_MRPGetHandleByIndex((LSA_UINT16)(inter_face));
	if (OHA_IS_NULL(pHDBMrp))
	{
		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_mrpDomainEntry() - no such MRP interface");
		return(LSA_NULL);
	}
	NICId = pHDBMrp->Params.pDetail->Params.Mrp.NICId;

    OHA_MEMCPY((char *)name, (char *)newname, (int)vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

	RingPort_Id1 = pHDBMrp->MrpStateInd[instance_id-1].rPort1;
	RingPort_Id2 = pHDBMrp->MrpStateInd[instance_id-1].rPort2;
	Instance_Id  = pHDBMrp->MrpStateInd[instance_id-1].mrpInstance; /* ever indicated ? */

    switch (vp->magic)
    {
        case MRPDOMAININDEX: /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;   /* FAIL return.*/
            }
            long_return = (LSA_INT32)domain;
            return (U_CHAR *)&long_return;

        case MRPDOMAINID:	/* IEC62439UuidType */
			if (RingPort_Id1 && RingPort_Id2)
			{
				LSA_UINT8 SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS_MRP;
				(LSA_VOID)oha_db_read_loc_lldp_element(NICId,
													   RingPort_Id1, OHA_LLDP_TYPE_ORG_SPECIFIC,
													   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
													   &NamePtr, &Len);
				if (!(OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_MRP_SIZE)))
				{
					NamePtr = LSA_NULL;
				}
			}
			if (OHA_IS_NULL(NamePtr))
			{
				NamePtr = pHDBMrp->MrpStateInd[instance_id-1].domainUUID;
			}
            *var_len = sizeof(OHA_UUID_TYPE);
            return (U_CHAR *)NamePtr;

        case MRPDOMAINNAME: /* from MrpGetStatus */
			if (Instance_Id)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			NamePtr = pHDBMrp->MrpGetStatus[instance_id-1].pDomainName;
			if (OHA_IS_NOT_NULL(NamePtr))
			{
	            *var_len = (LSA_INT)pHDBMrp->MrpGetStatus[instance_id-1].domainNameLength;
			}
			else
			{
				NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&pHDBMrp->MrpGetStatus[instance_id - 1].domainNameLength; /* RQ 2588726 */
				*var_len = 0;
			}
            return (U_CHAR *)NamePtr;

        case MRPDOMAINADMINROLE:
			/*  SnmpSet: The agent restricts the write access, it shall reject write requests */
			/* by responding with 'badValue'. */
			long_return = pHDBMrp->MrpStateInd[instance_id-1].adminRole;
            return (U_CHAR *)&long_return;

        case MRPDOMAINOPERROLE:
			long_return = pHDBMrp->MrpStateInd[instance_id-1].operRole;
            return (U_CHAR *)&long_return;

        case MRPDOMAINRINGPORT1: /* from "SockGetMib2Params" */
			{
				OHA_HDB_EDD_PTR_TYPE  pHDBEdd = OHA_EDDGetHandleByNIC(NICId);
				if (OHA_IS_NOT_NULL(pHDBEdd) && RingPort_Id1)	 /* The ifIndex of the layer 2 interface */
				{
					long_return = (LSA_INT32)pHDBEdd->Mib2IfIndex[RingPort_Id1];
				}
				else
				{
					long_return = 0;
				}
			}
            return (U_CHAR *)&long_return;

        case MRPDOMAINRINGPORT1STATE: /* from MrpGetStatus */
			if (RingPort_Id1)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			if(pHDBMrp->MrpGetStatus[instance_id-1].rPort1State) /* (0) is not in the MIB! */
			{
				switch(pHDBMrp->MrpGetStatus[instance_id-1].rPort1State)
				{
					case MRP_MIB_RPORT_STATE_DISABLED:
					case MRP_MIB_RPORT_STATE_BLOCKED:
					case MRP_MIB_RPORT_STATE_FORWARDING:
					case MRP_MIB_RPORT_STATE_NOT_CONNECTED:
						long_return = pHDBMrp->MrpGetStatus[instance_id-1].rPort1State;
					break;
					default:
						long_return = MRP_MIB_RPORT_STATE_DISABLED;
					break;
				}
			}
			else	 /* default value */
			{
				long_return = MRP_MIB_RPORT_STATE_DISABLED;
			}
			return (U_CHAR *)&long_return;

        case MRPDOMAINRINGPORT2: /* from "SockGetMib2Params" */
			{
				OHA_HDB_EDD_PTR_TYPE  pHDBEdd = OHA_EDDGetHandleByNIC(NICId);
				if (OHA_IS_NOT_NULL(pHDBEdd) && RingPort_Id2) /* The ifIndex of the layer 2 interface */
				{
					long_return = (LSA_INT32)pHDBEdd->Mib2IfIndex[RingPort_Id2];
				}
				else
				{
					long_return = 0;
				}
			}
            return (U_CHAR *)&long_return;

        case MRPDOMAINRINGPORT2STATE: /* from MrpGetStatus */
			if (RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			if(pHDBMrp->MrpGetStatus[instance_id-1].rPort2State) /* (0) is not in the MIB! */
			{
				switch(pHDBMrp->MrpGetStatus[instance_id-1].rPort2State)
				{
					case MRP_MIB_RPORT_STATE_DISABLED:
					case MRP_MIB_RPORT_STATE_BLOCKED:
					case MRP_MIB_RPORT_STATE_FORWARDING:
					case MRP_MIB_RPORT_STATE_NOT_CONNECTED:
						long_return = pHDBMrp->MrpGetStatus[instance_id-1].rPort2State;
					break;
					default:
						long_return = MRP_MIB_RPORT_STATE_DISABLED;
					break;
				}
			}
			else	 /* default value */
			{
				long_return = MRP_MIB_RPORT_STATE_DISABLED;
			}
			return (U_CHAR *)&long_return;

        case MRPDOMAINSTATE: /* from MrpGetStatus */
			/*	 SYNTAX BITS { disabled (0),
								undefined (1),
								ringOpen (2),
								reserved (3) } */
			if (RingPort_Id1 && RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;

				switch(pHDBMrp->MrpGetStatus[instance_id-1].domainState)
				{
					case MRP_MIB_DOMAIN_STATE_DISABLED:
						byte_return = 0x80;
					break;
					case MRP_MIB_DOMAIN_STATE_UNDEFINED:
						byte_return = 0x40;
					break;
					case MRP_MIB_DOMAIN_STATE_RINGOPEN:
						byte_return = 0x20;
					break;
					case MRP_MIB_DOMAIN_STATE_RESERVED:
						byte_return = 0x10;
					break;
					case MRP_MIB_DOMAIN_STATE_RINGCLOSED:
						byte_return = 0x00;
					break;
					default:
						byte_return = 0x80;
					break;
				}
			}
			else	/* default value */
			{
				byte_return = 0x80; /* MRP switched off (disabled) */
			}

            *var_len = 1;   /* SYNTAX:  (4 bits) */
			return (U_CHAR *)&byte_return;

        case MRPDOMAINERROR: /* from MrpGetStatus */
			/*	 SYNTAX BITS { noError (0),
								invalidVlanId (1),
								invalid (2),
								multipleMRM (3),
								singleSideReceive (4) } */
			if (RingPort_Id1 && RingPort_Id2)
			{
				byte_return = 0x00;
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;

				if(pHDBMrp->MrpGetStatus[instance_id-1].domainError & MRP_MIB_DOMAIN_NO_ERR)
				{
					byte_return |= 0x80;
				}
				if(pHDBMrp->MrpGetStatus[instance_id-1].domainError & MRP_MIB_DOMAIN_ERR_INVALID_VLANID)
				{
					byte_return |= 0x40;
				}
				if(pHDBMrp->MrpGetStatus[instance_id-1].domainError & MRP_MIB_DOMAIN_ERR_INVALID)
				{
					byte_return |= 0x20;
				}
				if(pHDBMrp->MrpGetStatus[instance_id-1].domainError & MRP_MIB_DOMAIN_ERR_MULTIPLE_MRM)
				{
					byte_return |= 0x10;
				}
				if(pHDBMrp->MrpGetStatus[instance_id-1].domainError & MRP_MIB_DOMAIN_ERR_SINGLE_SIDE_RECEIVE)
				{
					byte_return |= 0x08;
				}
			}
			else	/* default value */
			{
				byte_return = 0x80; /* NO_ERR */
			}

            *var_len = 1;   /* SYNTAX:  (4 bits) */
			return (U_CHAR *)&byte_return;

        case MRPDOMAINBLOCKED:
			if (pHDBMrp->MrpStateInd[instance_id-1].domainBlocked) /* (0) is not in the MIB! */
			{
				long_return = pHDBMrp->MrpStateInd[instance_id-1].domainBlocked;
			}
			else	 /* default value */
			{
				long_return = MRP_MIB_DOMAIN_BLOCKED_DISABLED;
			}
            return (U_CHAR *)&long_return;

        case MRPDOMAINVLANID:
			long_return = (LSA_INT32)pHDBMrp->MrpStateInd[instance_id-1].domainVlanId;
            return (U_CHAR *)&long_return;

        case MRPDOMAINMANAGERPRIORITY:
			long_return = (LSA_INT32)pHDBMrp->MrpStateInd[instance_id-1].domainManagerPrio;
            return (U_CHAR *)&long_return;

        case MRPDOMAINRINGOPENCOUNT: /* from MrpGetStatus */
			if (RingPort_Id1 && RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			long_return = (LSA_INT32)pHDBMrp->MrpGetStatus[instance_id-1].domainRingOpenCount;
            return (U_CHAR *)&long_return;

        case MRPDOMAINLASTRINGOPENCHANGE: /* from MrpGetStatus */
			if (RingPort_Id1 && RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			long_return = (LSA_INT32)pHDBMrp->MrpGetStatus[instance_id-1].domainLastRingOpenChange;
            return (U_CHAR *)&long_return;

        case MRPDOMAINROUNDTRIPDELAYMAX: /* from MrpGetStatus */
			if (RingPort_Id1 && RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			long_return = (LSA_INT32)pHDBMrp->MrpGetStatus[instance_id-1].domainRoundTripDelayMax;
            return (U_CHAR *)&long_return;

        case MRPDOMAINROUNDTRIPDELAYMIN: /* from MrpGetStatus */
			if (RingPort_Id1 && RingPort_Id2)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			long_return = (LSA_INT32)pHDBMrp->MrpGetStatus[instance_id-1].domainRoundTripDelayMin;
            return (U_CHAR *)&long_return;

        case MRPDOMAINRESETROUNDTRIPDELAYS:	/* SYNTAX INTEGER { resetDelays (1)	} */
			if (RingPort_Id1 && RingPort_Id2 && oper == SET_OP)
			{
				oha_mrp_stats_info[inter_face-1][instance_id-1] = OHA_HANDLE_TYPE_MRP;
			}
			long_return = 1;
            return (U_CHAR *)&long_return;

        case MRPDOMAINMRMREACTONLINKCHANGE:
			if(pHDBMrp->MrpStateInd[instance_id-1].domainMrmReactOnLinkChange) /* (0) is not in the MIB! */
			{
				long_return = (LSA_INT32)pHDBMrp->MrpStateInd[instance_id-1].domainMrmReactOnLinkChange;
			}
			else	/* default value */
			{
				long_return = MRP_MIB_DOMAIN_BLOCKED_DISABLED;
			}
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_mrpDomainEntry(): Unknown magic number");
		break;
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_mrpDomainEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*+                                                                         +*/
/*+  Functionname          :    OHA_MRPCountStats                           +*/
/*+  Input/Output          :    OHA_HDB_PTR_TYPE             pHDB           +*/
/*+                                                                         +*/
/*+  Result                :    LSA_UINT16                                  +*/
/*+-------------------------------------------------------------------------+*/
/*+  Input/Output:                                                          +*/
/*+                                                                         +*/
/*+  pHDB                 : Pointer to HDB                                  +*/
/*+                                                                         +*/
/*+  Result               : CountOfStatsNeeded                              +*/
/*+                                                                         +*/
/*+-------------------------------------------------------------------------+*/
/*+  Description: Reads necessary status from MRP                           +*/
/*+                                                                         +*/
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
LSA_UINT16 OHA_MRPCountStats(
    LSA_UINT16                   Orginator,
	LSA_UINT8                    MessageType)
{
    LSA_UINT16  CountOfStats = 0;
    LSA_UINT16  ifs, instance;

    OHA_FUNCTION_TRACE_02(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : OHA_MRPCountStats(Orginator: 0x%X, MessageType:  0x%X)", Orginator, MessageType);

	OHA_ASSERT (MessageType == OHA_SNMP_GET_REQ ||
				MessageType == OHA_SNMP_GETNEXT_REQ ||
				MessageType == OHA_SNMP_SET_REQ);

    /* statistic data (asynchronous) from MRP_OPC_GET_STATUS needed ? */
    for (ifs=0; ifs < OHA_CFG_MAX_NICS; ifs++)
    {
		for (instance=0; instance < EDD_CFG_MAX_MRP_INSTANCE_CNT; instance++)
		{
			OHA_ASSERT (oha_mrp_stats_info[ifs][instance] == 0 ||
						oha_mrp_stats_info[ifs][instance] == OHA_HANDLE_TYPE_MRP ||
						oha_mrp_stats_info[ifs][instance] == OHA_HANDLE_TYPE_SOCK); /* sanity */

			if (oha_mrp_stats_info[ifs][instance])
			{
				LSA_UINT16 RetVal;
				OHA_HDB_MRP_PTR_TYPE pMrpHDB = OHA_MRPGetHandleByIndex((LSA_UINT16)(ifs+1));
				if (OHA_IS_NULL(pMrpHDB))
				{
					OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_NOTE, "OUT: OHA_MRPCountStats(If: 0x%X) - no such interface for MRP", (ifs+1));
					continue;
				}

				switch(oha_mrp_stats_info[ifs][instance])
				{
					case OHA_HANDLE_TYPE_MRP:
					{
						if (MessageType == OHA_SNMP_SET_REQ)
						{
							RetVal = OHA_MRPSetStatus(pMrpHDB, Orginator, (LSA_UINT16)(instance+1));
							if (RetVal == OHA_OK)
							{
								CountOfStats++;
							}
							break;
						}
						RetVal = OHA_MRPGetStatus(pMrpHDB, Orginator, (LSA_UINT16)(instance+1));
						if (RetVal == OHA_OK)
						{
							CountOfStats++;
						}
					}
					break;
					default:
						OHA_FATAL(OHA_FATAL_ERR_HANDLE_INVALID);
					break;
				}
			}
		}
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: OHA_MRPCountStats(CountOfStats: 0x%X)", CountOfStats);
    return(CountOfStats);
}

#endif    /* OHA_CFG_NO_MRP_MIB */
#endif    /* OHA_CFG_NO_MRP     */

/*****************************************************************************/
/*  end of file OHA_MIBR.C                                                   */
/*****************************************************************************/
