/*
    C code file Generated by InterNiche Technologies MIB Compiler
    Copyright 1993-1999 by InterNiche Technologies
*/
/*****************************************************************************/
/** Copyright 1990-96 by NetPort Software. All rights reserved.              */
/** Copyright 1996-2004 By InterNiche Technologies Inc. All rights reserved. */
/*  Copyright (C) 2020 Siemens Aktiengesellschaft. All rights reserved.      */
/*****************************************************************************/
/*  This program is protected by German copyright law and international      */
/*  treaties. The use of this software including but not limited to its      */
/*  Source Code is subject to restrictions as agreed in the license          */
/*  agreement between you and Siemens.                                       */
/*  Copying or distribution is not allowed unless expressly permitted        */
/*  according to your license agreement with Siemens.                        */
/*****************************************************************************/
/*                                                                           */
/*  P r o j e c t         &P: PROFINET IO Runtime Software              :P&  */
/*                                                                           */
/*  P a c k a g e         &W: PROFINET IO Runtime Software              :W&  */
/*                                                                           */
/*  C o m p o n e n t     &C: OHA (Option HAndler)                      :C&  */
/*                                                                           */
/*  F i l e               &F: oha_mibs.c                                :F&  */
/*                                                                           */
/*  V e r s i o n         &V: BC_PNRUN_P07.02.00.00_00.02.00.20         :V&  */
/*                                                                           */
/*  D a t e  (YYYY-MM-DD) &D: 2020-09-21                                :D&  */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  D e s c r i p t i o n:  OHA SNMP-Agent functions                         */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  H i s t o r y :                                                          */
/*  ________________________________________________________________________ */
/*                                                                           */
/*  Date        Who   What                                                   */
/*  20.07.04    VE    initial version.                                       */
/*****************************************************************************/

#define LTRC_ACT_MODUL_ID 34
#define OHA_MODULE_ID     LTRC_ACT_MODUL_ID /* OHA_MODULE_ID_OHA_MIBS */

/*===========================================================================*/
/*                                 includes                                  */
/*===========================================================================*/

#include "oha_inc.h"            /* OHA headerfiles  */
#include "oha_int.h"            /* internal header  */

/* BTRACE-IF */
OHA_FILE_SYSTEM_EXTENSION(OHA_MODULE_ID)

#include "oha_asn1.h"
#include "oha_agnt.h"           /* OHA-Agent header */
#include "oha_snmp.h"           /* SNMP header      */

#include "oha_mibs.h"

/*===========================================================================*/
/*                                global Variables                           */
/*===========================================================================*/

/* SPLINT: Initializer does not define all elements of a declared array.     */
/*     Initializer block for oha_snmp_variables[0].name                      */
/*     has 10 elements, but declared as unsigned long int [17],...           */
/* TFS 960410: SNMP GET-NEXT returns not-accessible defined objects.         */
/*     -> "not accessible" objects removed                                   */

struct snmp_variable oha_snmp_variables[] =
{
    {{1,0,8802,1,1,2,1,1,1,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPMESSAGETXINTERVAL, OHA_SNMP_RWRITE, var_lldpConfiguration },
    {{1,0,8802,1,1,2,1,1,2,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPMESSAGETXHOLDMULTIPLIER, OHA_SNMP_RWRITE, var_lldpConfiguration },
    {{1,0,8802,1,1,2,1,1,3,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPREINITDELAY, OHA_SNMP_RWRITE, var_lldpConfiguration },
    {{1,0,8802,1,1,2,1,1,4,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPTXDELAY, OHA_SNMP_RWRITE, var_lldpConfiguration },
    {{1,0,8802,1,1,2,1,1,5,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPNOTIFICATIONINTERVAL, OHA_SNMP_RWRITE, var_lldpConfiguration },
    {{1,0,8802,1,1,2,1,1,6,1,2,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPPORTCONFIGADMINSTATUS, OHA_SNMP_RWRITE, var_lldpPortConfigEntry },
    {{1,0,8802,1,1,2,1,1,6,1,3,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPPORTCONFIGNOTIFICATIONENABLE, OHA_SNMP_RWRITE, var_lldpPortConfigEntry },
    {{1,0,8802,1,1,2,1,1,6,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPPORTCONFIGTLVSTXENABLE, OHA_SNMP_RWRITE, var_lldpPortConfigEntry },
    {{1,0,8802,1,1,2,1,1,7,1,1,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPCONFIGMANADDRPORTSTXENABLE, OHA_SNMP_RWRITE, var_lldpConfigManAddrEntry },
    {{1,0,8802,1,1,2,1,2,1,0, 0,0,0,0,0,0,0,0,0,0}, 10, OHA_SNMP_TIMETICKS, LLDPSTATSREMTABLESLASTCHANGETIME, OHA_SNMP_RONLY, var_lldpStatistics },
    {{1,0,8802,1,1,2,1,2,2,0, 0,0,0,0,0,0,0,0,0,0}, 10, OHA_SNMP_GAUGE, LLDPSTATSREMTABLESINSERTS, OHA_SNMP_RONLY, var_lldpStatistics },
    {{1,0,8802,1,1,2,1,2,3,0, 0,0,0,0,0,0,0,0,0,0}, 10, OHA_SNMP_GAUGE, LLDPSTATSREMTABLESDELETES, OHA_SNMP_RONLY, var_lldpStatistics },
    {{1,0,8802,1,1,2,1,2,4,0, 0,0,0,0,0,0,0,0,0,0}, 10, OHA_SNMP_GAUGE, LLDPSTATSREMTABLESDROPS, OHA_SNMP_RONLY, var_lldpStatistics },
    {{1,0,8802,1,1,2,1,2,5,0, 0,0,0,0,0,0,0,0,0,0}, 10, OHA_SNMP_GAUGE, LLDPSTATSREMTABLESAGEOUTS, OHA_SNMP_RONLY, var_lldpStatistics },

    {{1,0,8802,1,1,2,1,2,6,1,2,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSTXPORTFRAMESTOTAL, OHA_SNMP_RONLY, var_lldpStatsTxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,2,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,3,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSRXPORTFRAMESERRORS, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSRXPORTFRAMESTOTAL, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,5,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSRXPORTTLVSDISCARDEDTOTAL, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,6,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_COUNTER, LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,2,7,1,7,0xFF, 0,0,0,0,0,0,0,0},  12, OHA_SNMP_GAUGE, LLDPSTATSRXPORTAGEOUTSTOTAL, OHA_SNMP_RONLY, var_lldpStatsRxPortEntry },
    {{1,0,8802,1,1,2,1,3,1,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_INTEGER, LLDPLOCCHASSISIDSUBTYPE, OHA_SNMP_RONLY, var_lldpLocalSystemData },
    {{1,0,8802,1,1,2,1,3,2,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_OCTET_STR, LLDPLOCCHASSISID, OHA_SNMP_RONLY, var_lldpLocalSystemData },
    {{1,0,8802,1,1,2,1,3,3,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_OCTET_STR, LLDPLOCSYSNAME, OHA_SNMP_RONLY, var_lldpLocalSystemData },
    {{1,0,8802,1,1,2,1,3,4,0, 0,0,0,0,0,0,0,0,0,0}, 10, ASN_OCTET_STR, LLDPLOCSYSDESC, OHA_SNMP_RONLY, var_lldpLocalSystemData },
    {{1,0,8802,1,1,2,1,3,5,0, 0,0,0,0,0,0,0,0,0,0}, 10, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPLOCSYSCAPSUPPORTED, OHA_SNMP_RONLY, var_lldpLocalSystemData },
    {{1,0,8802,1,1,2,1,3,6,0, 0,0,0,0,0,0,0,0,0,0}, 10, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPLOCSYSCAPENABLED, OHA_SNMP_RONLY, var_lldpLocalSystemData },

    {{1,0,8802,1,1,2,1,3,7,1,2,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPLOCPORTIDSUBTYPE, OHA_SNMP_RONLY, var_lldpLocPortEntry },
    {{1,0,8802,1,1,2,1,3,7,1,3,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPLOCPORTID, OHA_SNMP_RONLY, var_lldpLocPortEntry },
    {{1,0,8802,1,1,2,1,3,7,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPLOCPORTDESC, OHA_SNMP_RONLY, var_lldpLocPortEntry },

    {{1,0,8802,1,1,2,1,3,8,1,3,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPLOCMANADDRLEN, OHA_SNMP_RONLY, var_lldpLocManAddrEntry },
    {{1,0,8802,1,1,2,1,3,8,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPLOCMANADDRIFSUBTYPE, OHA_SNMP_RONLY, var_lldpLocManAddrEntry },
    {{1,0,8802,1,1,2,1,3,8,1,5,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPLOCMANADDRIFID, OHA_SNMP_RONLY, var_lldpLocManAddrEntry },
    {{1,0,8802,1,1,2,1,3,8,1,6,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OBJECT_ID, LLDPLOCMANADDROID, OHA_SNMP_RONLY, var_lldpLocManAddrEntry },

    {{1,0,8802,1,1,2,1,4,1,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPREMCHASSISIDSUBTYPE, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,5,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMCHASSISID, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,6,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPREMPORTIDSUBTYPE, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,7,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMPORTID, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,8,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMPORTDESC, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,9,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMSYSNAME, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,10,0xFF, 0,0,0,0,0,0,0,0}, 12, ASN_OCTET_STR, LLDPREMSYSDESC, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,11,0xFF, 0,0,0,0,0,0,0,0}, 12, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPREMSYSCAPSUPPORTED, OHA_SNMP_RONLY, var_lldpRemEntry },
    {{1,0,8802,1,1,2,1,4,1,1,12,0xFF, 0,0,0,0,0,0,0,0}, 12, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPREMSYSCAPENABLED, OHA_SNMP_RONLY, var_lldpRemEntry },

    {{1,0,8802,1,1,2,1,4,2,1,3,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPREMMANADDRIFSUBTYPE, OHA_SNMP_RONLY, var_lldpRemManAddrEntry },
    {{1,0,8802,1,1,2,1,4,2,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_INTEGER, LLDPREMMANADDRIFID, OHA_SNMP_RONLY, var_lldpRemManAddrEntry },
    {{1,0,8802,1,1,2,1,4,2,1,5,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OBJECT_ID, LLDPREMMANADDROID, OHA_SNMP_RONLY, var_lldpRemManAddrEntry },
    {{1,0,8802,1,1,2,1,4,3,1,2,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMUNKNOWNTLVINFO, OHA_SNMP_RONLY, var_lldpRemUnknownTLVEntry },
    {{1,0,8802,1,1,2,1,4,4,1,4,0xFF, 0,0,0,0,0,0,0,0},  12, ASN_OCTET_STR, LLDPREMORGDEFINFO, OHA_SNMP_RONLY, var_lldpRemOrgDefInfoEntry },

    {{1,0,8802,1,1,2,1,5,3791,1,1,1,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOCONFIGSPDTXENABLE, OHA_SNMP_RWRITE, var_lldpXPnoConfigEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,1,1,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOCONFIGPORTSTATUSTXENABLE, OHA_SNMP_RWRITE, var_lldpXPnoConfigEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,1,1,1,3,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOCONFIGALIASTXENABLE, OHA_SNMP_RWRITE, var_lldpXPnoConfigEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,1,1,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOCONFIGMRPTXENABLE, OHA_SNMP_RWRITE, var_lldpXPnoConfigEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,1,1,1,5,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOCONFIGPTCPTXENABLE, OHA_SNMP_RWRITE, var_lldpXPnoConfigEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,1,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCLPDVALUE, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,2,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTTXDVALUE, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,3,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTRXDVALUE, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT2, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,5,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,6,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOLOCPORTNOS, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,7,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOLOCPORTMRPUUID, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,8,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTMRRTSTATUS, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,9,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOLOCPORTPTCPMASTER, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,10,0xFF,0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOLOCPORTPTCPSUBDOMAINUUID, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,11,0xFF,0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOLOCPORTPTCPIRDATAUUID, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,12,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTMODERT3, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,13,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTPERIODLENGTH, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,14,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTPERIODVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,15,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTREDOFFSET, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,16,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTREDVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,17,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTORANGEOFFSET, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,18,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTORANGEVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,19,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOLOCPORTGREENOFFSET, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,2,1,1,20,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOLOCPORTGREENVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,2,1,1,21,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3OPTIMIZATIONSUPPORTED, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,2,1,1,22,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENINGSUPPORTED, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,2,1,1,23,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENING, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,2,1,1,24,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATIONSUPPORTED, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,2,1,1,25,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATION, OHA_SNMP_RONLY, var_lldpXPnoLocEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,1,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMLPDVALUE, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,2,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTTXDVALUE, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,3,0xFF, 0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTRXDVALUE, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTSTATUSRT2, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,5,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTSTATUSRT3, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,6,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOREMPORTNOS, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,7,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOREMPORTMRPUUID, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,8,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTMRRTSTATUS, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,9,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOREMPORTPTCPMASTER, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,10,0xFF,0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOREMPORTPTCPSUBDOMAINUUID, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,11,0xFF,0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXPNOREMPORTPTCPIRDATAUUID, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,12,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTMODERT3, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,13,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTPERIODLENGTH, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,14,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTPERIODVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,15,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTREDOFFSET, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,16,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTREDVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,17,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTORANGEOFFSET, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,18,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTORANGEVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,19,0xFF,0,0,0,0,0},   15, OHA_SNMP_UNSIGNED32, LLDPXPNOREMPORTGREENOFFSET, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
    {{1,0,8802,1,1,2,1,5,3791,1,3,1,1,20,0xFF,0,0,0,0,0},   15, ASN_INTEGER, LLDPXPNOREMPORTGREENVALIDITY, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,3,1,1,21,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOREMPORTSTATUSRT3PREAMBLESHORTENING, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },
	{{1,0,8802,1,1,2,1,5,3791,1,3,1,1,22,0xFF,0,0,0,0,0},	15, ASN_INTEGER, LLDPXPNOREMPORTSTATUSRT3FRAGMENTATION, OHA_SNMP_RONLY, var_lldpXPnoRemEntry },

    {{1,0,8802,1,1,2,1,5,4623,1,1,1,1,1,0xFF, 0,0,0,0,0},   15, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPXDOT3PORTCONFIGTLVSTXENABLE, OHA_SNMP_RWRITE, var_lldpXdot3PortConfigEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,1,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPORTAUTONEGSUPPORTED, OHA_SNMP_RONLY, var_lldpXdot3LocPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,1,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPORTAUTONEGENABLED, OHA_SNMP_RONLY, var_lldpXdot3LocPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,1,1,3,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXDOT3LOCPORTAUTONEGADVERTISEDCAP, OHA_SNMP_RONLY, var_lldpXdot3LocPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,1,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPORTOPERMAUTYPE, OHA_SNMP_RONLY, var_lldpXdot3LocPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERPORTCLASS, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERMDISUPPORTED, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,3,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERMDIENABLED, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERPAIRCONTROLABLE, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,5,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERPAIRS, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,2,1,6,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCPOWERCLASS, OHA_SNMP_RONLY, var_lldpXdot3LocPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,3,1,1,0xFF, 0,0,0,0,0},   15, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPXDOT3LOCLINKAGGSTATUS, OHA_SNMP_RONLY, var_lldpXdot3LocLinkAggEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,3,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCLINKAGGPORTID, OHA_SNMP_RONLY, var_lldpXdot3LocLinkAggEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,2,4,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3LOCMAXFRAMESIZE, OHA_SNMP_RONLY, var_lldpXdot3LocMaxFrameSizeEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,1,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPORTAUTONEGSUPPORTED, OHA_SNMP_RONLY, var_lldpXdot3RemPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,1,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPORTAUTONEGENABLED, OHA_SNMP_RONLY, var_lldpXdot3RemPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,1,1,3,0xFF, 0,0,0,0,0},   15, ASN_OCTET_STR, LLDPXDOT3REMPORTAUTONEGADVERTISEDCAP, OHA_SNMP_RONLY, var_lldpXdot3RemPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,1,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPORTOPERMAUTYPE, OHA_SNMP_RONLY, var_lldpXdot3RemPortEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERPORTCLASS, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERMDISUPPORTED, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,3,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERMDIENABLED, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,4,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERPAIRCONTROLABLE, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,5,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERPAIRS, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,2,1,6,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMPOWERCLASS, OHA_SNMP_RONLY, var_lldpXdot3RemPowerEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,3,1,1,0xFF, 0,0,0,0,0},   15, /* ASN_BIT_STR */ ASN_OCTET_STR, LLDPXDOT3REMLINKAGGSTATUS, OHA_SNMP_RONLY, var_lldpXdot3RemLinkAggEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,3,1,2,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMLINKAGGPORTID, OHA_SNMP_RONLY, var_lldpXdot3RemLinkAggEntry },
    {{1,0,8802,1,1,2,1,5,4623,1,3,4,1,1,0xFF, 0,0,0,0,0},   15, ASN_INTEGER, LLDPXDOT3REMMAXFRAMESIZE, OHA_SNMP_RONLY, var_lldpXdot3RemMaxFrameSizeEntry },

    {{1,0,8802,1,1,2,1,5,32962,1,1,1,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1CONFIGPORTVLANTXENABLE, OHA_SNMP_RWRITE, var_lldpXdot1ConfigPortVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,1,2,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1CONFIGVLANNAMETXENABLE, OHA_SNMP_RWRITE, var_lldpXdot1ConfigVlanNameEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,1,3,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1CONFIGPROTOVLANTXENABLE, OHA_SNMP_RWRITE, var_lldpXdot1ConfigProtoVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,1,4,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1CONFIGPROTOCOLTXENABLE, OHA_SNMP_RWRITE, var_lldpXdot1ConfigProtocolEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,2,1,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1LOCPORTVLANID, OHA_SNMP_RONLY, var_lldpXdot1LocEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,2,2,1,2,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1LOCPROTOVLANSUPPORTED, OHA_SNMP_RONLY, var_lldpXdot1LocProtoVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,2,2,1,3,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1LOCPROTOVLANENABLED, OHA_SNMP_RONLY, var_lldpXdot1LocProtoVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,2,3,1,2,0xFF, 0,0,0,0,0}, 15, ASN_OCTET_STR, LLDPXDOT1LOCVLANNAME, OHA_SNMP_RONLY, var_lldpXdot1LocVlanNameEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,2,4,1,2,0xFF, 0,0,0,0,0}, 15, ASN_OCTET_STR, LLDPXDOT1LOCPROTOCOLID, OHA_SNMP_RONLY, var_lldpXdot1LocProtocolEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,3,1,1,1,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1REMPORTVLANID, OHA_SNMP_RONLY, var_lldpXdot1RemEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,3,2,1,2,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1REMPROTOVLANSUPPORTED, OHA_SNMP_RONLY, var_lldpXdot1RemProtoVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,3,2,1,3,0xFF, 0,0,0,0,0}, 15, ASN_INTEGER, LLDPXDOT1REMPROTOVLANENABLED, OHA_SNMP_RONLY, var_lldpXdot1RemProtoVlanEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,3,3,1,2,0xFF, 0,0,0,0,0}, 15, ASN_OCTET_STR, LLDPXDOT1REMVLANNAME, OHA_SNMP_RONLY, var_lldpXdot1RemVlanNameEntry },
    {{1,0,8802,1,1,2,1,5,32962,1,3,4,1,2,0xFF, 0,0,0,0,0}, 15, ASN_OCTET_STR, LLDPXDOT1REMPROTOCOLID, OHA_SNMP_RONLY, var_lldpXdot1RemProtocolEntry },
};

/* As variables[] is put in FAR_DATA segment, code that implements
   get_num_variables() and get_variables_arr() is compiler dependent.
   Hence it is put in a different file, called specific.c */

/* Microsoft compiler is not neat in handing int variables across
 * object files in a LARGE model. So when num_variables is accessed
 * in getStatPtr() in snmp.c, invalid data segment is used, and hence
 * incorrect value gets picked up. (Same is true with integer
 * pointers also). Hence this function.
 */

/* As sys_uptime[], snmptrapoid[] and snmpgenoid[] are used by
 * other files, its better to put a fixed size, instead of [].
 * Previously they were specified with [] and that made some compilers
 * (VC++ 6.0) generate bad code (sys_uptime would point to 0x01)
 * at point of use
 */
/* OHA_OID  sys_uptime[9] = { 1,3,6,1,2,1,1,3,0 } ;
   unsigned sys_uptime_len = sizeof ( sys_uptime )/sizeof(OHA_OID);
   OHA_OID  snmptrapoid[11] = { 1,3,6,1,6,3,1,1,4,1,0 } ;
   unsigned snmptrapoid_len = sizeof ( snmptrapoid )/sizeof(OHA_OID);
   OHA_OID  snmpgenoid[11] = { 1,3,6,1,6,3,1,1,5,1,0 } ;
*/

/* statistics to read from LLDP */
static OHA_STATS_INFO_TYPE oha_stats_info;

/*===========================================================================*/
/*                                functions                                  */
/*===========================================================================*/

/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
/*+                                                                         +*/
/*+  Functionname          :    OHA_GetIf                                   +*/
/*+  Input/Output          :    LSA_UINT16       IfId                       +*/
/*+  Result                :    OHA_DB_IF_PTR_TYPE                          +*/
/*+-------------------------------------------------------------------------+*/
/*+                                                                         +*/
/*+  Input/Output:                                                          +*/
/*+                                                                         +*/
/*+  InterfaceId      : InterfaceId from Table   1...n                      +*/
/*+                                                                         +*/
/*+-------------------------------------------------------------------------+*/
/*+  Description: Gets Pointer to a DB IF with IfIndex. If none is found    +*/
/*+               LSA_NULL is returned                                      +*/
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
OHA_DB_IF_PTR_TYPE OHA_GetIf(
    LSA_UINT16 IfIndex)
{
    OHA_HDB_LLDP_PTR_TYPE pHDBLldp;

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : OHA_GetIf(IfId: 0x%X)",
                          IfIndex);
    if (IfIndex && (IfIndex <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
    {
        pHDBLldp = OHA_GET_HLLDP_PTR(IfIndex-1);
        if ( pHDBLldp && (pHDBLldp->State == OHA_HANDLE_STATE_OPEN) )
        {
            OHA_ASSERT_NULL_PTR(pHDBLldp->pDB);
            OHA_ASSERT_NULL_PTR(pHDBLldp->Params.pDetail);
            OHA_ASSERT(pHDBLldp->pDB->NicId == pHDBLldp->Params.pDetail->Params.Lldp.NICId);
            OHA_ASSERT (pHDBLldp->pDB->PortCnt <= OHA_CFG_MAX_PORTS);
            OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: OHA_GetIf(pDB:  0x%X)", pHDBLldp->pDB);
            return(pHDBLldp->pDB);
        }
        else
        {
            OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: OHA_GetIf(pHDB:  0x%X)", pHDBLldp);
            return(LSA_NULL);
        }
    }
    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: OHA_GetIf()");
    return(LSA_NULL);
}

/* FUNCTION: oha_snmp_get_if_id()
 *
 * PARAM1:   lldpPortNumber (1...n)
 *
 * RETURNS:  if_id (1...OHA_CFG_MAX_NICS), port_id (1...OHA_CFG_MAX_PORTS)
 */
LSA_UINT oha_snmp_get_if_id(LSA_UINT lldpPortNumber, LSA_UINT *port_id)
{
    LSA_UINT16 port_number;
    LSA_UINT16 inter_face;

    OHA_ASSERT(lldpPortNumber != 0);

    for (inter_face = 1, port_number = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(inter_face);
        if (OHA_IS_NOT_NULL(pDB))
        {
            LSA_UINT16 PortIndex;

            for (PortIndex = 0; port_number <= lldpPortNumber &&
                 PortIndex < pDB->PortCnt; port_number++, PortIndex++)
            {
                if (port_number == lldpPortNumber)
                {
                    if (OHA_IS_NOT_NULL(port_id))
                    {
                        *port_id = PortIndex + 1;
                    }
                    OHA_FUNCTION_TRACE_02(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_get_inter_face(IfID: 0x%X, PortID: 0x%X)", inter_face, (PortIndex + 1));
                    return(inter_face);
                }
            }
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_get_inter_face()");
    return(0);
}

/* FUNCTION: oha_snmp_get_port_id()
 *
 * PARAM1:   if_id (1...OHA_CFG_MAX_NICS), port_id (1...OHA_CFG_MAX_PORTS)
 *
 * RETURNS:  lldpPortNumber (1...n)
 */
static unsigned oha_snmp_get_port_id(unsigned inter_face, unsigned port_id)
{
    LSA_UINT16 i;
    unsigned lldpPortId;

    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    for (i = 1, lldpPortId = 1; i <= OHA_CFG_MAX_NICS; i++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(i);
        if (OHA_IS_NOT_NULL(pDB))
        {
            LSA_UINT16 PortIndex;

            for (PortIndex = 1; PortIndex <= pDB->PortCnt; lldpPortId++, PortIndex++)
            {
                if (port_id == PortIndex)
                {
                    if (inter_face == i)
                    {
                        OHA_FUNCTION_TRACE_03(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_get_port_id(IfID: 0x%X, PortID: 0x%X, lldpPortID: 0x%X)", inter_face, port_id, lldpPortId);
                        return(lldpPortId);
                    }
                }
            }
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_NOTE, "IN/OUT: oha_snmp_get_port_id() failed!");
    return(0);
}

/* FUNCTION: oha_snmp_count_if_ports()
 *
 * PARAM1:
 *
 * RETURNS:  number of all ports
 */

LSA_UINT16 oha_snmp_count_if_ports(void)
{
    LSA_UINT32 ports = 0;
    LSA_UINT16 i;

    for (i = 1; i <= OHA_CFG_MAX_NICS; i++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(i);
        if (OHA_IS_NOT_NULL(pDB))
        {
            ports += pDB->PortCnt;
        }
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_count_if_ports(num:  0x%X)", ports);
    return (LSA_UINT16)ports;
}

/* FUNCTION: oha_snmp_count_if_statistics()
 *
 * PARAM1:
 *
 * RETURNS:  ok, not ok
 */

static OHA_OID_STATS_PTR_TYPE oha_snmp_count_if_statistics(void)
{
    static OHA_OID_STATS_TYPE LldpStatistics;
    LSA_UINT16 i;
    LSA_BOOL IfFound = LSA_FALSE;

	LldpStatistics.LastChangeTime = 0;	/* init. */
	LldpStatistics.RemTabAgeouts  = 0;
	LldpStatistics.RemTabDeletes  = 0;
	LldpStatistics.RemTabDrops    = 0;
	LldpStatistics.RemTabInserts  = 0;

    for (i = 1; i <= OHA_CFG_MAX_NICS; i++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(i);
        if (OHA_IS_NOT_NULL(pDB))
        {
            if (pDB->LldpStatistics.LastChangeTime > LldpStatistics.LastChangeTime)
            {
                LldpStatistics.LastChangeTime = pDB->LldpStatistics.LastChangeTime;
            }
            LldpStatistics.RemTabAgeouts  += pDB->LldpStatistics.RemTabAgeouts;
            LldpStatistics.RemTabDeletes  += pDB->LldpStatistics.RemTabDeletes;
            LldpStatistics.RemTabDrops    += pDB->LldpStatistics.RemTabDrops;
            LldpStatistics.RemTabInserts  += pDB->LldpStatistics.RemTabInserts;

            IfFound = LSA_TRUE;
        }
    }

    if (!IfFound)   /* no If found */
    {
        OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_count_if_statistics(IfFound:  0x%X)", IfFound);
        return LSA_NULL;
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_count_if_statistics(IfFound:  0x%X)", IfFound);
    return &LldpStatistics;
}

/* FUNCTION: snmp_get_num_variables()
 *
 * PARAM1:
 *
 * RETURNS:
 */

int oha_snmp_get_num_variables(void)
{
    int   num=sizeof(oha_snmp_variables)/sizeof(struct snmp_variable);

    /* OHA_MEMSET(&oha_stats_info, 0, sizeof(oha_stats_info)); */  /* AP01388134: no reset by getStatPtr()! */

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "IN/OUT: oha_snmp_get_num_variables(num:  0x%X)", num);
    return num;
}

/* FUNCTION: snmp_get_variables_arr()
 *
 * PARAM1: void
 *
 * RETURNS:
 */

/* Borland compiler gives "fixup error" when variables[] is used in snmp.c
 * So, we will use get_variables_arr() to access variables[].
 */

#ifdef __BORLANDC__
struct snmp_variable * _loadds oha_snmp_get_variables_arr(void)
#else
struct snmp_variable *  oha_snmp_get_variables_arr(void)
#endif
{
    return   oha_snmp_variables;
}

/* FUNCTION: oha_snmp_get_stats_info()
 *
 * PARAM1:
 *
 * RETURNS:
 */

OHA_STATS_INFO_PTR_TYPE oha_snmp_get_stats_info(LSA_VOID)
{
	return(&oha_stats_info);
}

/* FUNCTION: oha_snmp_get_lldp_statistics()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_UINT32 oha_snmp_get_lldp_statistics(LSA_VOID)
{
    LSA_UINT32  CountOfStats = 0;
    LSA_UINT16  ifs, ports;

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : oha_snmp_get_lldp_statistics()");

    if (oha_stats_info.GlobOptions)
    {
        CountOfStats++;
    }

    for (ifs=0; ifs < OHA_CFG_MAX_NICS; ifs++)
    {
		if(oha_stats_info.IfOptions[ifs])
		{
            CountOfStats++;
		}
        for (ports=0; ports < OHA_CFG_MAX_PORTS; ports++)
        {
            if (oha_stats_info.PortOptions[ifs][ports])
            {
                CountOfStats++;
            }
        }
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: oha_snmp_get_lldp_statistics(StatsInfo: 0x%X)", CountOfStats);

    return CountOfStats;
}

/* FUNCTION: oha_snmp_get_lldp_config_options()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_UINT32 oha_snmp_get_lldp_config_options(LSA_VOID)
{
	return(oha_stats_info.GlobOptions);
}

/* FUNCTION: oha_snmp_set_lldp_config_options()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_VOID oha_snmp_set_lldp_config_options(LSA_UINT32 option)
{
	oha_stats_info.GlobOptions = option;
	return;
}

/* FUNCTION: oha_snmp_get_lldp_port_config_options(LSA_UINT16 ifs, LSA_UINT16 port)
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_UINT32 oha_snmp_get_lldp_port_config_options(LSA_UINT16 nic_id, LSA_UINT16 port_id)
{
	LSA_UINT16 if_index;

	if (!(port_id > 0 && port_id <= OHA_CFG_MAX_PORTS))
	{
		OHA_FATAL(OHA_FATAL_ERR_INCONSISTENZ);  /* NOTREACHED */
		return(0);
	}
    for (if_index = 1; if_index <= OHA_CFG_MAX_NICS; if_index++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(if_index);
        if (OHA_IS_NOT_NULL(pDB) && nic_id == pDB->NicId)
		{
			return(oha_stats_info.PortOptions[if_index-1][port_id-1]);
		}
	}
	return(0);
}


/* FUNCTION: oha_snmp_set_lldp_port_config_options(LSA_UINT16 ifs, LSA_UINT16 port)
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_UINT32 oha_snmp_set_lldp_port_config_options(LSA_UINT16 nic_id, LSA_UINT16 port_id, LSA_UINT32 options)
{
	LSA_UINT16 if_index;

	if (!(port_id > 0 && port_id <= OHA_CFG_MAX_PORTS))
	{
		OHA_FATAL(OHA_FATAL_ERR_INCONSISTENZ);  /* NOTREACHED */
		return(0);
	}
    for (if_index = 1; if_index <= OHA_CFG_MAX_NICS; if_index++)
    {
        OHA_DB_IF_PTR_TYPE pDB = OHA_GetIf(if_index);
        if (OHA_IS_NOT_NULL(pDB) && nic_id == pDB->NicId)
		{
			oha_stats_info.PortOptions[if_index-1][port_id-1] = options;
			return(1);
		}
	}
	return(0);
}

/* FUNCTION: oha_snmp_delete_lldp_statistics()
 *
 * PARAM1:
 *
 * RETURNS:
 */

LSA_VOID oha_snmp_delete_lldp_statistics(LSA_VOID)
{
    LSA_UINT16  ifs, ports;

	oha_stats_info.GlobOptions = 0;

    for (ifs=0; ifs < OHA_CFG_MAX_NICS; ifs++)
    {
		oha_stats_info.IfOptions[ifs] = 0;

		for (ports=0; ports < OHA_CFG_MAX_PORTS; ports++)
        {
            oha_stats_info.PortOptions[ifs][ports] = 0;
        }
    }
    return;
}

/* FUNCTION: OHA_GetSystemCapabilitiesMap()
 *
 * PARAM1:   LSA_UINT8 SystemCapabilities
 *
 * Converts the IEEE 802.1AB SystemCapabilities to
   MIB bitfield coding (see RFC 3417):

  other (0)             1000 0000	0x80  128
  repeater (1)          0100 0000	0x40   64
  bridge (2)            0010 0000	0x20   32
  wlanAcessPoint (3)    0001 0000	0x10   16
  router (4)            0000 1000	0x08    8
  telephone (5)         0000 0100	0x04    4
  docsisCableDevice (6) 0000 0010	0x02    2
  stationOnly (7)       0000 0001	0x01    1

 * RETURNS:  LSA_UINT8 SystemCapabilitiesMap
 */
static LSA_UINT8 OHA_GetSystemCapabilitiesMap(LSA_UINT8 SystemCapabilities)
{
	LSA_UINT8 SystemCapabilitiesMap = 0;

	if ((SystemCapabilities & LLDP_TLV_SYSCAB_OTHER) == LLDP_TLV_SYSCAB_OTHER) /* 0x0001 */
    {
        SystemCapabilitiesMap |= 0x80;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_REPEATER) == LLDP_TLV_SYSCAB_REPEATER) /* 0x0002 */
    {
        SystemCapabilitiesMap |= 0x40;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_BRIDGE) == LLDP_TLV_SYSCAB_BRIDGE) /* 0x0004 */
    {
        SystemCapabilitiesMap |= 0x20;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_WLAN_ACCESS_POINT) == LLDP_TLV_SYSCAB_WLAN_ACCESS_POINT) /* 0x0008 */
    {
        SystemCapabilitiesMap |= 0x10;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_ROUTER) == LLDP_TLV_SYSCAB_ROUTER) /* 0x0010 */
    {
        SystemCapabilitiesMap |= 0x08;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_TELEPHONE) == LLDP_TLV_SYSCAB_TELEPHONE) /* 0x0020 */
    {
        SystemCapabilitiesMap |= 0x04;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_DOCSIS_CABLE_DEVICE) == LLDP_TLV_SYSCAB_DOCSIS_CABLE_DEVICE) /* 0x0040 */
    {
        SystemCapabilitiesMap |= 0x02;
    }
	if ((SystemCapabilities & LLDP_TLV_SYSCAB_STATION_ONLY) == LLDP_TLV_SYSCAB_STATION_ONLY) /* 0x0080 */
    {
        SystemCapabilitiesMap |= 0x01;
    }

    return (SystemCapabilitiesMap);
}

/* 'var_' routine frames for variables table */

U_CHAR *  var_lldpConfiguration(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32  long_return =  0L;
	LSA_UINT8       AccessControl = OHA_NO_ACCESS;

    /* there are no dependences of entities (interfaces) in the LLDP.MIB !   */
    /* therefore LldpConfiguration data must be identical for all interfaces */
	/* so we look for the first interface and read the config data from here */
	OHA_DB_IF_PTR_TYPE   pDB = OHA_GetIf(1);

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpConfiguration(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    if (OHA_IS_NULL(pDB))
        return LSA_NULL; /* FAIL return.*/

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    if (oper && (oha_snmp_compare(name, (unsigned)(*length), vp->name, vp->namelen) != 0))
        return LSA_NULL;

    OHA_MEMCPY(name, vp->name, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default length */

    if (oper == SET_OP)  /* force range checking on sets */
    {
		LSA_UINT32 mib_option;
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

        oha_set_parms.do_range = LSA_TRUE;

        switch (vp->magic)
        {
            case LLDPMESSAGETXINTERVAL:         /* lldpMessageTxInterval (5..32768 seconds)  */
                oha_set_parms.hi_range = OHA_LLDP_TX_INTERVAL_MAX;
                oha_set_parms.lo_range = OHA_LLDP_TX_INTERVAL_MIN;
                /* oha_set_parms.access_method = oha_snmp_set_TxInterval;  */
				mib_option  = OHA_CTRL_TX_INTERVAL;
                break;
            case LLDPMESSAGETXHOLDMULTIPLIER:   /* lldpMessageTxHoldMultiplier (2..10 seconds) */
                oha_set_parms.hi_range = OHA_LLDP_TTL_FACTOR_MAX;
                oha_set_parms.lo_range = OHA_LLDP_TTL_FACTOR_MIN;
				mib_option  = OHA_CTRL_TX_HOLD_MULTIPLIER;
                break;
            case LLDPREINITDELAY:               /* lldpReinitDelay           */
                oha_set_parms.hi_range = 10;    /* SYNTAX Integer32 (1..10 seconds) */
                oha_set_parms.lo_range = 1;
				mib_option  = OHA_CTRL_REINIT_DELAY;
                break;
            case LLDPTXDELAY:                   /* lldpTxDelay               */
                oha_set_parms.hi_range = 8192;  /* SYNTAX Integer32 (1..8192 seconds) */
                oha_set_parms.lo_range = 1;
				mib_option  = OHA_CTRL_TX_DELAY;
                break;
            case LLDPNOTIFICATIONINTERVAL:      /* lldpNotificationInterval  */
                oha_set_parms.hi_range = 3600;  /* SYNTAX Integer32 (5..3600 seconds) */
                oha_set_parms.lo_range = 5;
				mib_option  = OHA_CTRL_NOTIFICATION_INTERVAL;
                break;
            default:
                oha_set_parms.do_range = LSA_FALSE;
			    return LSA_NULL;
        }

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_ACCESS(mib_option, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.GlobOptions |= mib_option;

		(LSA_VOID)oha_db_read_temp_lldp_mib_value(mib_option, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpConfiguration() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    /* Note to lldpReinitDelay, lldpTxDelay: 0 is handled special with set to 0  */
    /* we send the frame immediately without jitter!                             */
    switch (vp->magic)
    {
        case LLDPMESSAGETXINTERVAL:       /* lldpMessageTxInterval        */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_VALUE(OHA_CTRL_TX_INTERVAL, (OHA_COMMON_MEM_U32_PTR_TYPE)&long_return, LSA_NULL, LSA_NULL);
            return (U_CHAR*)&long_return;
        case LLDPMESSAGETXHOLDMULTIPLIER: /* lldpMessageTxHoldMultiplier  */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_VALUE(OHA_CTRL_TX_HOLD_MULTIPLIER, (OHA_COMMON_MEM_U32_PTR_TYPE)&long_return, LSA_NULL, LSA_NULL);
            return (U_CHAR*)&long_return;
        case LLDPREINITDELAY:             /* lldpReinitDelay              */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_VALUE(OHA_CTRL_REINIT_DELAY, (OHA_COMMON_MEM_U32_PTR_TYPE)&long_return, LSA_NULL, LSA_NULL);
            long_return = (long_return == 0) ? 1 : long_return; /* LLDP_DEFAULT_TX_REINIT_DELAY */
            return (U_CHAR*)&long_return;
        case LLDPTXDELAY:                 /* lldpTxDelay                  */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_VALUE(OHA_CTRL_TX_DELAY, (OHA_COMMON_MEM_U32_PTR_TYPE)&long_return, LSA_NULL, LSA_NULL);
            long_return = (long_return == 0) ? 1 : long_return; /* LLDP_DEFAULT_TX_DELAY */
            return (U_CHAR*)&long_return;
        case LLDPNOTIFICATIONINTERVAL:    /* lldpNotificationInterval     */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_ACCESS(OHA_CTRL_NOTIFICATION_INTERVAL, &AccessControl);
			if (AccessControl == OHA_NO_ACCESS)
			{
                return LSA_NULL;              /* not supported                */
			}
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_VALUE(OHA_CTRL_NOTIFICATION_INTERVAL, (OHA_COMMON_MEM_U32_PTR_TYPE)&long_return, LSA_NULL, LSA_NULL);
            return (U_CHAR*)&long_return;
        default:
            OHA_SNMPERROR("var_lldpConfiguration(): Unknown magic number");
		break;
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpConfiguration() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}

U_CHAR *  var_lldpPortConfigEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face;
    unsigned   port;
    static LSA_INT32 long_return =  0L;
    static LSA_UINT8 byte_return = 0;
    LSA_UINT16 PortCnt;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE       pDB;
    /* enum lldpPortConfigAdminStatus
    {
        txOnly   = 1,
        rxOnly   = 2,
        txAndRx  = 3,
        disabled = 4
    }; */
	LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpPortConfigEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(length);
    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" interface */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[11/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt) /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - no such port_number");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!(pDB))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - no such interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(var_len);
    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    if (oper == SET_OP)  /* force range checking on sets */
    {
		LSA_UINT32 mib_option;
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

        switch (vp->magic)
        {
	        case LLDPPORTCONFIGADMINSTATUS: /* lldpPortConfigAdminStatus */
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_DISABLED;
                oha_set_parms.lo_range = OHA_LLDP_SEND_ONLY;
				mib_option  = OHA_CTRL_ADMIN_STATUS;
                break;
	        case LLDPPORTCONFIGNOTIFICATIONENABLE: /* lldpPortConfigNotificationEnable */
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
                oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;
				mib_option  = OHA_CTRL_NOTIFICATION;
                break;
	        case LLDPPORTCONFIGTLVSTXENABLE: /* lldpPortConfigTLVsTxEnable */
				oha_set_parms.vbflags |= SF_NOASCIICHK;
				mib_option  = OHA_CTRL_LLDP_TLVS;
				*var_len = 1;   /* SYNTAX:  (4 bits) */
                break;
            default:
                oha_set_parms.do_range = LSA_FALSE;
			    return LSA_NULL;
        }

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)port_id, mib_option, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.PortOptions[inter_face-1][port_id-1] |= mib_option;

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)port_id, mib_option, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPPORTCONFIGPORTNUM:  /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;   /* FAIL return.*/
            }
            long_return =  (LSA_INT32)(port + 1);      /* we store 'em 0 thru n-1, snmp wants 1 thru n */
            return (U_CHAR *)&long_return;

        case LLDPPORTCONFIGADMINSTATUS: /* lldpPortConfigAdminStatus */
		{
			LSA_UINT32 AdminStatus = 0;
            (LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_ADMIN_STATUS,
													  &AdminStatus, LSA_NULL, LSA_NULL);
			/*   SYNTAX INTEGER {
					txOnly (1),
					rxOnly (2),
					txAndRx (3),
					disabled (4)
 					}    */
            switch (AdminStatus)
            {
                case OHA_LLDP_SEND_ONLY:
                case OHA_LLDP_RECV_ONLY:
                case OHA_LLDP_SEND_RECV:
                case OHA_LLDP_DISABLED:
                    long_return = (LSA_INT32)AdminStatus;
                    break;
                default:
                    OHA_PROGRAM_TRACE_01(0, LSA_TRACE_LEVEL_FATAL,"var_lldpPortConfigEntry(): Invalid AdminStatus (%Xh)",pDB->LldpData[port_id-1].PortConfig.AdminStatus.Value);
                    break;
            }

            return (U_CHAR *)&long_return;
		}
        case LLDPPORTCONFIGNOTIFICATIONENABLE: /* lldpPortConfigNotificationEnable */
			/* AP01306487: lldpPortConfigNotificationEnable has the value "1" */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_NOTIFICATION,
													  &TxEnable, LSA_NULL, LSA_NULL);
            long_return = (LSA_INT32)TxEnable;
            return (U_CHAR *)&long_return;

        case LLDPPORTCONFIGTLVSTXENABLE: /* lldpPortConfigTLVsTxEnable */
		{
            /*   SYNTAX BITS {
                portDesc (0),
                sysName (1),
                sysDesc (2),
                sysCap (3)
                }       */
			byte_return = 0;		   /* is send allowed ? */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_LLDP_TLVS,
													  &TxEnable, LSA_NULL, LSA_NULL);
			byte_return = (LSA_UINT8)TxEnable;
            *var_len = 1;   /* SYNTAX:  (4 bits) */
            return (U_CHAR *)&byte_return;
		}

        default:
            OHA_SNMPERROR("var_lldpLocPortConfigEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}


U_CHAR *
var_lldpConfigManAddrEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
#define OHA_CONFIG_MANADDR_ENTRY_OIDLEN     (11 + 1 + Len)  /* length of address table lldpConfigManAddrEntry */

    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face;
    OHA_DB_IF_PTR_TYPE      pDB;
    LSA_UINT16 PortCnt;
    OHA_COMMON_MEM_U8_PTR_TYPE pVar    = LSA_NULL;
    OHA_COMMON_MEM_U8_PTR_TYPE pSubnet = LSA_NULL;
    OHA_COMMON_MEM_U8_PTR_TYPE pRouter = LSA_NULL;
    LSA_INT Len;
    OHA_COMMON_MEM_U8_PTR_TYPE low_ip  = LSA_NULL; /* lowest entry we found */
    unsigned low_if = 0;
	LSA_UINT16 LenByte = 1;     /* AP00736394 -> a lenbyte is to set before the ip address */
	LSA_INT  low_len = 0;

    static LSA_UINT8 PortTable[32]; /* table for max. 255 ports (one bit per port) */
	LSA_UINT16 port;
    LSA_UINT8  port_idx = 0; /* max. 255 ports */

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpConfigManAddrEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpConfigManAddrEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[11] = 0; /* init. (reserved) lldpLocManAddrSubtype */
    current[9] = 0; /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* scan at table for closest match */
    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)     /* if this entry isn't valid */
        {
            continue;
        }

        /* read from DB (IP Address) */
        Len = OHA_DB_READ_IP_SUITE(pDB->NicId, &pVar, &pSubnet, &pRouter);
        if (LSA_HOST_PTR_ARE_EQUAL(pVar, LSA_NULL) || Len != OHA_IP_ADDR_SIZE)
        {
            continue;
        }

        /* create object id reflecting this lldpConfigManAddr table entry's lldpLocManAddrSubtype & lldpLocManAddr */
		if (OHA_MEMCMP(pVar, (OHA_COMMON_MEM_PTR_TYPE)OHA_ZERO_IP, OHA_IP_ADDR_SIZE)) /* IP is 0.0.0.0 ? */
		{
			/* read from DB (MAC Address) */
			Len = OHA_DB_READ_MAC_ADDR(pDB->NicId, &pVar);
			if (LSA_HOST_PTR_ARE_EQUAL(pVar, LSA_NULL) || Len != OHA_MAC_ADDR_SIZE) /* no MAC */
			{
				continue;
			}

			/* Oid: 1.0.8802.1.1.2.1.1.7.1.1.subtype(6).Len.mac-a.mac-b.mac-c.mac-d.mac-e.mac-f */
			/* set lldpLocManAddrSubtype in objId */
			current[vp->namelen - 1] = (OHA_OID)OHA_ADDR_FAMILY_MAC_ADDR;
		}
		else
		{
			/* Oid: 1.0.8802.1.1.2.1.1.7.1.1.subtype(1).Len.ip-a.ip-b.ip-c.ip-d */
			/* set lldpLocManAddrSubtype in objId */
			current[vp->namelen - 1] = (OHA_OID)OHA_ADDR_FAMILY_IPV4;
		}
		OHA_ASSERT(Len);
        /* copy length of management address into current (AP00736394) */
        if (LenByte)
        {
            current[vp->namelen] = (OHA_OID)Len; /* len = 4 (IPv4 is used), len = 6 (MAC is used) */
        }

        /* copy management address into current. */
        {
            OHA_COMMON_MEM_U8_PTR_TYPE cp = pVar;
            LSA_UINT16 i;
            for (i = vp->namelen; i < vp->namelen + Len; i++) /* current[12+LenByte]...current[15(17)+LenByte] */
                current[i+LenByte] = *cp++;
        }

        if (oper)   /* operation is SET or GET */
        {
            if (oha_snmp_compare(current, OHA_CONFIG_MANADDR_ENTRY_OIDLEN+LenByte, name, (unsigned)(*length)) == 0)
            {
                OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+Len+LenByte) * sizeof(OHA_OID));
                low_ip = pVar;
                low_if = inter_face;
				low_len = Len;
                break;   /* no need to search further */
            }
        }
        else     /* caller wants closest match */
        {
            /* if new one is greater than input and closer to input than
             * previous lowest, save this one as the "next" one. */
            if ((oha_snmp_compare(current, OHA_CONFIG_MANADDR_ENTRY_OIDLEN+LenByte, name, (unsigned)(*length)) > 0) &&
                (!low_ip || (oha_snmp_compare(current, OHA_CONFIG_MANADDR_ENTRY_OIDLEN+LenByte, lowest, OHA_CONFIG_MANADDR_ENTRY_OIDLEN+LenByte) < 0)))
            {
                OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+Len+LenByte) * sizeof(OHA_OID));
                low_ip = pVar;
                low_if = inter_face;
				low_len = Len;
            }
        }
    }   /* end for lldp_mib loop */

    if (OHA_IS_NULL(low_ip))
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+low_len+LenByte) * sizeof(OHA_OID));
    *length = (vp->namelen+low_len+LenByte);
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    if (oper == SET_OP)  /* force range checking on sets */
    {
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = LSA_NULL; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

		switch (vp->magic)
		{
			case LLDPCONFIGMANADDRPORTSTXENABLE: /* lldpConfigManAddrPortsTxEnable */
            break;
            default:
		    return LSA_NULL;
        }

		oha_set_parms.vbflags |= SF_NOASCIICHK;

		/* port access from every port of this interface */
		for(port = 0;  port < pDB->PortCnt; port++)
		{
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)(port+1), OHA_CTRL_LLDP_MAN_ADDR, &AccessControl);
			if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
			{
				return LSA_NULL;              /* nothing set */
			}
		}

		if (!(inter_face > 0 && inter_face <= OHA_CFG_MAX_NICS))
		{
			OHA_FATAL(OHA_FATAL_ERR_INCONSISTENZ);  /* NOTREACHED */
			return(LSA_NULL);
		}
		oha_stats_info.IfOptions[inter_face-1] |= OHA_CTRL_LLDP_MAN_ADDR;

		/* we set the value to the interface */
		(LSA_VOID)oha_db_read_temp_lldp_mib_if_value(pDB->NicId, OHA_CTRL_LLDP_MAN_ADDR, (OHA_COMMON_MEM_U8_PTR_TYPE *)&mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpConfigManAddrEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

	switch (vp->magic)
    {
        case LLDPCONFIGMANADDRPORTSTXENABLE: /* lldpConfigManAddrPortsTxEnable */

            /* fill the port-bits */
            /* "Each octet within this value specifies a set of eight ports,  */
            /* with the first octet specifying ports 1 through 8, the second  */
            /* octet specifying ports 9 through 16, etc.  Within each octet,  */
            /* the most significant bit represents the lowest numbered port,  */
            /* and the least significant bit represents the highest numbered  */
            /* port.  Thus, each port of the system is represented by a       */
            /* single bit within the value of this object.  If that bit has   */
            /* a value of '1' then that port is included in the set of ports; */
            /* the port is not included if its bit has a value of '0'."       */

            OHA_MEMSET(PortTable, 0, 32);
            {
		        pDB = OHA_GetIf((LSA_UINT16)(low_if));
				OHA_ASSERT_NULL_PTR(pDB);

                for (port = 0; (port < 255) && (port < pDB->PortCnt); port++)
                {
                    LSA_UINT8 Help = 1;

					/* AP01568640: need the portindex over all interfaces */
                    port_idx = (LSA_UINT8)oha_snmp_get_port_id(low_if, port + 1);

					if (port_idx == 0) /* error */
					{
					    OHA_PROGRAM_TRACE_03(0, LSA_TRACE_LEVEL_UNEXP,"var_lldpConfigManAddrEntry (If:  0x%X, PortId: 0x%X, PortIndex: 0x%X)",low_if,(port+1),port_idx);
						break;
					}

				    OHA_PROGRAM_TRACE_03(0, LSA_TRACE_LEVEL_NOTE_LOW,"var_lldpConfigManAddrEntry (If:  0x%X, PortId: 0x%X, PortIndex: 0x%X)",low_if,(port+1),port_idx);

                    Help = (LSA_UINT8)(Help << (7 - ((port_idx-1) % 8)));

                    /* set the corresponding port "bits" only */
                    {
						LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;
						(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)(port+1), OHA_CTRL_LLDP_MAN_ADDR, (OHA_COMMON_MEM_U32_PTR_TYPE)&TxEnable, LSA_NULL, LSA_NULL);
						if(TxEnable == OHA_LLDP_TX_ENABLE)
						{
	                        PortTable[(port_idx-1)/8] |= Help;
						}
                    }
                }
            }

            *var_len = (port_idx + 7) / 8;
            return (U_CHAR *)&PortTable;

        default:
            OHA_SNMPERROR("var_lldpConfigManAddrEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpConfigManAddrEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}


U_CHAR *  var_lldpStatistics(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32     long_return =  0L;
    OHA_OID_STATS_PTR_TYPE   pLldpStatistics = oha_snmp_count_if_statistics();

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpStatistics(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    if (OHA_IS_NOT_NULL(pLldpStatistics))
    {
		OHA_ASSERT_NULL_PTR(length);
		OHA_ASSERT_NULL_PTR(vp);
		OHA_ASSERT_NULL_PTR(var_len);

        if (oper && (oha_snmp_compare(name, (unsigned)(*length), vp->name, vp->namelen) != 0))
            return LSA_NULL;

        OHA_MEMCPY(name, vp->name, vp->namelen * sizeof(OHA_OID));
        *length = vp->namelen;
        *var_len = sizeof(LSA_INT32);   /* default length */

        switch (vp->magic)
        {
            case LLDPSTATSREMTABLESLASTCHANGETIME:  /* lldpStatsRemTablesLastChangeTime */
                long_return = (LSA_INT32)pLldpStatistics->LastChangeTime;
                return (U_CHAR*)&long_return;
            case LLDPSTATSREMTABLESINSERTS:         /* lldpStatsRemTablesInserts */
                long_return = (LSA_INT32)pLldpStatistics->RemTabInserts;
                return (U_CHAR*)&long_return;
            case LLDPSTATSREMTABLESDELETES:         /* lldpStatsRemTablesDeletes */
                long_return = (LSA_INT32)pLldpStatistics->RemTabDeletes;
                return (U_CHAR*)&long_return;
            case LLDPSTATSREMTABLESDROPS:           /* lldpStatsRemTablesDrops   */
                long_return = (LSA_INT32)pLldpStatistics->RemTabDrops;
                return (U_CHAR*)&long_return;
            case LLDPSTATSREMTABLESAGEOUTS:         /* lldpStatsRemTablesAgeouts */
                long_return = (LSA_INT32)pLldpStatistics->RemTabAgeouts;
                return (U_CHAR*)&long_return;
            default:
                OHA_SNMPERROR("var_lldpStatistics(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatistics() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpStatsTxPortEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face;
    unsigned   port;
    static LSA_INT32  long_return =  0L;
    LSA_UINT16 PortCnt;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE pDB;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpStatsTxPortEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsTxPortEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

	newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" interface */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[11/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)    /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsTxPortEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!(pDB))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsTxPortEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    switch (vp->magic)
    {
        case LLDPSTATSTXPORTNUM:    /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
            long_return =  (LSA_INT32)port + 1;      /* we store 'em 0 thru n-1, snmp wants 1 thru n */
            return (U_CHAR *)&long_return;

            /* we've to get the (actual) statistic data (asynchronous) from LLDP_GET_STATS */
        case LLDPSTATSTXPORTFRAMESTOTAL:
            if (inter_face && (inter_face <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
            {
                oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_TX_FRAMESTOTAL;
            }
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.TxPortFramesTotal;
            return (U_CHAR*)&long_return;

        default:
            OHA_SNMPERROR("var_lldpStatsTxPortEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsTxPortEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpStatsRxPortEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face;
    unsigned   port;
    static LSA_INT32  long_return =  0L;
    LSA_UINT16 PortCnt;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE pDB;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpStatsRxPortEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsRxPortEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" interface */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[11/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)    /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsRxPortEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!(pDB))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsRxPortEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    switch (vp->magic)
    {
        case LLDPSTATSRXPORTNUM:    /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
            long_return =  (LSA_INT32)port + 1;      /* we store 'em 0 thru n-1, snmp wants 1 thru n */
            return (U_CHAR *)&long_return;

            /* we've to get the (actual) statistic data (asynchronous) from LLDP_GET_STATS */
        case LLDPSTATSRXPORTFRAMESDISCARDEDTOTAL:
            if (inter_face && (inter_face <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
            {
                oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_RX_FRAMESDISCARDEDTOTAL;
            }
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortFramesDiscardedTotal;
            return (U_CHAR*)&long_return;
            /* we've to get the (actual) statistic data (asynchronous) from LLDP_GET_STATS */
        case LLDPSTATSRXPORTFRAMESERRORS:
            if (inter_face && (inter_face <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
            {
                oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_RX_PORTFRAMESERRORS;
            }
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortFramesErrors;
            return (U_CHAR*)&long_return;
            /* we've to get the (actual) statistic data (asynchronous) from LLDP_GET_STATS */
        case LLDPSTATSRXPORTFRAMESTOTAL:
            if (inter_face && (inter_face <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
            {
                oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_RX_PORTFRAMESTOTAL;
            }
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortFramesTotal;
            return (U_CHAR*)&long_return;

            /* The number of LLDP TLVs discarded for any reason by this */
            /* LLDP agent on the indicated port.                        */
        case LLDPSTATSRXPORTTLVSDISCARDEDTOTAL:
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortTLVsDiscardedTotal;
            return (U_CHAR*)&long_return;

            /* An unrecognized TLV is referred to as the TLV whose type */
            /* value is in the range of reserved TLV types (9 - 126)    */
        case LLDPSTATSRXPORTTLVSUNRECOGNIZEDTOTAL:
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortTLVsUnrecognizedTotal;
            return (U_CHAR*)&long_return;

            /* we've to get the (actual) statistic data (asynchronous) from LLDP_GET_STATS */
        case LLDPSTATSRXPORTAGEOUTSTOTAL:
            if (inter_face && (inter_face <= OHA_CFG_MAX_NICS))    /* 0 is not valid */
            {
                oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_RX_PORTAGEOUTSTOTAL;
            }
            long_return = (LSA_INT32)pDB->LldpData[port_id-1].PortStats.RxPortAgeoutsTotal;
            return (U_CHAR*)&long_return;

        default:
            OHA_SNMPERROR("var_lldpStatsRxPortEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpStatsRxPortEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpLocalSystemData(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32 long_return = 0L;
    static LSA_UINT8 byte_return = 0;

    /* there are no dependences of entities (interfaces) in the LLDP.MIB !   */
    /* therefore LldpConfiguration data must be identical for all interfaces */
	/* so we look for the first interface and read the config data from here */
    OHA_DB_IF_PTR_TYPE   pDB = OHA_GetIf(1);
    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType = 0xff;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpLocalSystemData(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    if (OHA_IS_NOT_NULL(pDB))
    {
		LSA_UINT32 GlobalIfMode = OHA_DbGetGlobalIfMode(LSA_NULL, LSA_NULL);

		OHA_ASSERT_NULL_PTR(length);
		OHA_ASSERT_NULL_PTR(vp);
		OHA_ASSERT_NULL_PTR(var_len);

        if (oper && (oha_snmp_compare(name, (unsigned)(*length), vp->name, vp->namelen) != 0))
            return LSA_NULL;

        OHA_MEMCPY(name, vp->name, vp->namelen * sizeof(OHA_OID));
        *length = vp->namelen;
        *var_len = sizeof(long_return);   /* default length */

        switch (vp->magic)
        {
            case LLDPLOCCHASSISIDSUBTYPE:        /* lldpLocChassisIdSubtype */
				if(GlobalIfMode)
				{
					(LSA_VOID)OHA_DB_READ_CHASSIS_NAME(&pVar, &Len);
					OHA_ASSERT(Len != 0 && OHA_IS_NOT_NULL(pVar));	/* NameOfDevice existing */

					*var_len = sizeof(long_return);
					long_return = (U_LONG)OHA_CHASSIS_ID_LOCALLY_ASSIGNED;
					return (U_CHAR*)&long_return;
				}

				(LSA_VOID)OHA_DB_READ_LLDP_CHASSIS_ID(pDB->NicId, &pVar, &SubType);

				*var_len = sizeof(long_return);
				long_return = (U_LONG)SubType;
				return (U_CHAR*)&long_return;

            case LLDPLOCCHASSISID:               /* lldpLocChassisId      */
				if(GlobalIfMode)
				{
					(LSA_VOID)OHA_DB_READ_CHASSIS_NAME(&pVar, &Len);
					OHA_ASSERT(Len != 0 && OHA_IS_NOT_NULL(pVar));	/* NameOfDevice existing */

					NamePtr = pVar;
					*var_len = Len;
					return (U_CHAR *)NamePtr;
				}

				Len = OHA_DB_READ_LLDP_CHASSIS_ID(pDB->NicId, &pVar, &SubType);

                NamePtr = pVar;
				*var_len = Len;
                return (U_CHAR *)NamePtr;

            case LLDPLOCSYSNAME:                 /* lldpLocSysName  */
                (LSA_VOID)oha_db_read_loc_lldp_element(0, 0, OHA_LLDP_TYPE_SYSTEM_NAME,
                                                       &SubType, 0,
                                                       &pVar, &Len);
                NamePtr = pVar;
                *var_len = Len;
                if (OHA_IS_NOT_NULL(pVar))    /* if length is Null, do not deliver NoSuchName */
                {
                    return (U_CHAR *)NamePtr;
                }
                else
                {
                    long_return = 0;
                    return (U_CHAR *)&long_return;
                }

            case LLDPLOCSYSDESC:                 /* lldpLocSysDesc    */
                (LSA_VOID)oha_db_read_loc_lldp_element(0, 0, OHA_LLDP_TYPE_SYSTEM_DESCR,
                                                       &SubType, 0,
                                                       &pVar, &Len);
                NamePtr = pVar;
                *var_len = Len;
                return (U_CHAR *)NamePtr;

            case LLDPLOCSYSCAPSUPPORTED:         /* lldpLocSysCapSupported */
                /* NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&en_LldpSystemCapabilitiesMap[7].value; */
                /* *var_len = sizeof(en_LldpSystemCapabilitiesMap[7].value); */
                (LSA_VOID)oha_db_read_loc_lldp_element(0, 0, OHA_LLDP_TYPE_SYSTEM_CAP,
                                                       &SubType, 0,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && Len == LLDP_TLV_SYSTEM_CAP_SIZE) /* if length is Null, default values */
                {
                    LSA_UINT16    SystemCapabilities;

                    SystemCapabilities = OHA_GET16_NTOH (pVar, 0); /* 1st word */
                    byte_return = OHA_GetSystemCapabilitiesMap((LSA_UINT8)SystemCapabilities);
                }
                else
                {
                    byte_return = 0;
                }
                *var_len = 1; /* SYNTAX: LldpSystemCapabilitiesMap (8 bits) */
                return (U_CHAR *)&byte_return;

            case LLDPLOCSYSCAPENABLED:           /* lldpLocSysCapEnabled   */
                /* NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&en_LldpSystemCapabilitiesMap[7].value; */
                /* *var_len = sizeof(en_LldpSystemCapabilitiesMap[7].value); */
                (LSA_VOID)oha_db_read_loc_lldp_element(0, 0, OHA_LLDP_TYPE_SYSTEM_CAP,
                                                       &SubType, 0,
                                                       &pVar, &Len);

                if (OHA_IS_NOT_NULL(pVar) && Len == LLDP_TLV_SYSTEM_CAP_SIZE) /* if length is Null, default values */
                {
                    LSA_UINT16    EnabledCapabilities;

                    pVar += 2;    /* 2nd word */
                    EnabledCapabilities = OHA_GET16_NTOH (pVar, 0); /* 2nd word */
                    byte_return = OHA_GetSystemCapabilitiesMap((LSA_UINT8)EnabledCapabilities);
                }
                else
                {
                    byte_return = 0;
                }
                *var_len = 1; /* SYNTAX: LldpSystemCapabilitiesMap (8 bits) */
                return (U_CHAR *)&byte_return;

            default:
                OHA_SNMPERROR("var_lldpLocalSystemData(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocalSystemData() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpLocPortEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr;
    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType = 0;
    LSA_UINT16 PortCnt;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpLocPortEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpPortConfigEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" interface */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[11/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt) /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocPortEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocPortEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    switch (vp->magic)
    {
        case LLDPLOCPORTNUM: /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;   /* FAIL return.*/
            }
            long_return = (LSA_INT32)port + 1;      /* we store 'em 0 thru n-1, snmp wants 1 thru n */
            return (U_CHAR *)&long_return;

        case LLDPLOCPORTIDSUBTYPE:           /* lldpLocPortIdSubtype */
            if (oha_db_read_loc_lldp_element(pDB->NicId,
                                             (LSA_UINT16)(port_id), OHA_LLDP_TYPE_PORT_ID,
                                             &SubType, 0,
                                             &pVar, &Len) == LSA_RET_OK)
            {
                long_return = (U_LONG)SubType;
                return (U_CHAR*)&long_return;
            }
            break;

        case LLDPLOCPORTID:              /* lldpLocPortId    */
            Len = OHA_DB_READ_LLDP_PORT_ID(pDB->NicId, (LSA_UINT16)(port_id), &pVar);
            *var_len = Len;
            return (U_CHAR *)pVar;

        case LLDPLOCPORTDESC:         /* lldpLocPortDesc, IfDescr from IF-MIB  */
            if (pDB)
            {
                (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(port_id), OHA_LLDP_TYPE_PORT_DESCR,
                                                       &SubType, 0,
                                                       &pVar, &Len);
                *var_len = Len;
                NamePtr = pVar;
            }
            else
            {
                NamePtr = LSA_NULL;
                *var_len = 0;
            }
            return (U_CHAR *)NamePtr;

        default:
            OHA_SNMPERROR("var_lldpLocPortEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocPortEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}


U_CHAR *  var_lldpLocManAddrEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE low_addr  = LSA_NULL; /* lowest entry we found */
    unsigned low_if = 0;
	LSA_INT  low_len = 0;
    LSA_UINT16 LenByte = 1;     /* AP00736394 -> a lenbyte is to set before the ip address */

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpLocManAddrEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[11] = 0; /* init. (reserved) lldpLocManAddrSubtype */
    lowest[11+1] = 0; /* init. (reserved) lldpLocManAddrLen */
    current[9] = 0; /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, DEF_VARLEN * sizeof(OHA_OID));

    /* scan at table for closest match */
    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
		#define OHA_LOC_MANADDR_ENTRY_OIDLEN     (11 + 1 + VarLen)  /* length of address table lldpLocManAddrEntry */
		OHA_COMMON_MEM_U8_PTR_TYPE pVar    = LSA_NULL;
		LSA_INT VarLen;
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)     /* if this entry isn't valid */
        {
            continue;
        }

		/* AP01116719: MAC if no IP existing */
        /* read from DB (IP Address) */
        VarLen = OHA_DB_READ_IP_SUITE(pDB->NicId, &pVar, LSA_NULL, LSA_NULL);
        if (LSA_HOST_PTR_ARE_EQUAL(pVar, LSA_NULL) || VarLen != OHA_IP_ADDR_SIZE) /* no IP */
        {
            continue;
        }

        /* create object id reflecting this lldpLocManAddr table entry's lldpLocManAddrSubtype & lldpLocManAddr */
		if (OHA_MEMCMP(pVar,(OHA_COMMON_MEM_PTR_TYPE)OHA_ZERO_IP,OHA_IP_ADDR_SIZE)) /* IP is 0.0.0.0 ? */
		{
			/* read from DB (MAC Address) */
			VarLen = OHA_DB_READ_MAC_ADDR(pDB->NicId, &pVar);
			if (LSA_HOST_PTR_ARE_EQUAL(pVar, LSA_NULL) || VarLen != OHA_MAC_ADDR_SIZE) /* no MAC */
			{
				continue;
			}

			/* Oid: 1.0.8802.1.1.2.1.3.8.1.row.subtype(6).mac-a.mac-b.mac-c.mac-d.mac-e.mac-f */
			/* set lldpLocManAddrSubtype in objId */
			current[vp->namelen-1] = (OHA_OID)OHA_ADDR_FAMILY_MAC_ADDR;
		}
		else
		{
			/* Oid:  1.0.8802.1.1.2.1.3.8.1.row.subtype(1).ip-a.ip-b.ip-c.ip-d */
			/* set lldpLocManAddrSubtype in objId */
			current[vp->namelen-1] = (OHA_OID)OHA_ADDR_FAMILY_IPV4;
		}
		OHA_ASSERT(VarLen);

        /* copy length of management address into current (AP00736394) */
        if (LenByte)
        {
            current[vp->namelen] = (OHA_OID)VarLen; /* len = 4 (IPv4 is used), len = 6 (MAC is used) */
        }

        /* copy management address into current. */
        {
            OHA_COMMON_MEM_U8_PTR_TYPE cp = pVar;
            LSA_UINT16 i;
            for (i = vp->namelen; i < vp->namelen + VarLen; i++) /* current[12+LenByte]...current[15(17)+LenByte] */
                current[i+LenByte] = *cp++;
        }

        if (oper)   /* operation is SET or GET */
        {
            if (oha_snmp_compare(current, (unsigned)OHA_LOC_MANADDR_ENTRY_OIDLEN+LenByte, name, (unsigned)(*length)) == 0)
            {
                OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+VarLen+LenByte) * sizeof(OHA_OID));
                low_addr = pVar;
                low_if   = inter_face;
				low_len  = VarLen;
                break;   /* no need to search further */
            }
        }
        else     /* caller wants closest match */
        {
            /* if new one is greater than input and closer to input than
             * previous lowest, save this one as the "next" one. */
            if ((oha_snmp_compare(current, (unsigned)OHA_LOC_MANADDR_ENTRY_OIDLEN+LenByte, name, (unsigned)(*length)) > 0) &&
                (!low_addr || (oha_snmp_compare(current, (unsigned)OHA_LOC_MANADDR_ENTRY_OIDLEN+LenByte, lowest, (unsigned)OHA_LOC_MANADDR_ENTRY_OIDLEN+LenByte) < 0)))
            {
                OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+VarLen+LenByte) * sizeof(OHA_OID));
                low_addr = pVar;
                low_if   = inter_face;
				low_len  = VarLen;
            }
        }
    }   /* end for lldp_mib loop */

    if (OHA_IS_NULL(low_addr))
    {
        return(LSA_NULL); /* no match */
    }

	OHA_ASSERT(LenByte);

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+low_len+LenByte) * sizeof(OHA_OID));
    *length = (vp->namelen+low_len+LenByte);
    *var_len = sizeof long_return;   /* default return length */

    switch (vp->magic)
    {
        case LLDPLOCMANADDRSUBTYPE: /* not-accessible */ /* mgmt addr subtype */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
			OHA_ASSERT(lowest[11]==OHA_ADDR_FAMILY_IPV4||lowest[11]==OHA_ADDR_FAMILY_MAC_ADDR);
            long_return = (LSA_INT32)lowest[11];
            return (U_CHAR *)&long_return;

        case LLDPLOCMANADDR:            /* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;      /* FAIL return.*/
            }
			OHA_ASSERT(lowest[11+1]==OHA_IP_ADDR_SIZE||lowest[11+1]==OHA_MAC_ADDR_SIZE);
			*var_len = (int)lowest[11+1];	/* a lenbyte is set before the mgm address */
            return (U_CHAR *)low_addr;        /* management address (IP or MAC) */

            /* The total length of the management address subtype and the
            management address fields in LLDPDUs transmitted by the
            local LLDP agent. */
        case LLDPLOCMANADDRLEN:     /* 1 byte SubType + 4 byte (IP version 4) or 6 byte (MAC address) */
			OHA_ASSERT(lowest[11+1]==OHA_IP_ADDR_SIZE||lowest[11+1]==OHA_MAC_ADDR_SIZE);
            long_return = (LSA_INT32)lowest[11+1] + 1;	/* a lenbyte is set before the mgm address */
            return (U_CHAR *)&long_return;

        case LLDPLOCMANADDRIFSUBTYPE:   /* interface numbering subtype (2 = interface index) */
            long_return = LLDP_TLV_MGMADDR_IFNUM_IFINDEX;
            return (U_CHAR *)&long_return;

        case LLDPLOCMANADDRIFID:        /* interface number (interface id) */
			{
				OHA_HDB_EDD_PTR_TYPE  pHDBEdd;

				pDB = OHA_GetIf((LSA_UINT16)(low_if));
				OHA_ASSERT_NULL_PTR(pDB);
				pHDBEdd = OHA_EDDGetHandleByNIC(pDB->NicId);

				if (OHA_IS_NOT_NULL(pHDBEdd)) /* The ifIndex of the layer 2 interface */
				{
					long_return = (LSA_INT32)pHDBEdd->Mib2IfIndex[0]; /* 0 ... interface */
				}
				else
				{
					long_return = 0;
				}
				return (U_CHAR *)&long_return;
			}
        case LLDPLOCMANADDROID:     /* lldpLocManAddrOID {1.3.6.1.4.1.24686} */
        {
            static OHA_OID  Oid_lldpLocManAddrOID[] = {OHA_SNMP_PNO_SMI_OID};
            *var_len = OHA_SNMP_PNO_SMI_OID_LEN * sizeof(OHA_OID);
            return (U_CHAR *)&Oid_lldpLocManAddrOID;
        }
        default:
            OHA_SNMPERROR("var_lldpLocManAddrEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocManAddrEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}


static LSA_UINT16 var_lldpRemObject(
    LSA_UINT16 NICId,
    const struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    LSA_UINT16 LowPortId,       /* IN */
    LSA_UINT16 LowSenderId)     /* IN */
{
    LSA_UINT8  Type;        /* type of variable, option */
    LSA_UINT16 RetVal  = LSA_RET_OK;

    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
    LSA_UINT8  SubType = 0xff;
    LSA_UINT16 Len = 0;

	OHA_ASSERT_NULL_PTR(vp);

	OHA_FUNCTION_TRACE_03(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpRemObject(magic: 0x%X, LowPortId: 0x%X, LowSenderId: 0x%X)",
                          vp->magic, LowPortId, LowSenderId);

    switch (vp->magic)
    {
        case LLDPREMTIMEMARK:           /* not-accessible */
        case LLDPREMLOCALPORTNUM:       /* not-accessible */
        case LLDPREMINDEX:              /* not-accessible */
            Type = 0;
            break;
        case LLDPREMCHASSISIDSUBTYPE:   /* lldpRemChassisIdSubtype */
        case LLDPREMCHASSISID:          /* lldpRemChassisId */
			/* AP01234692: lldpRemChassisId   := LLDP_ChassisID */
            Type = OHA_LLDP_TYPE_CHASSIS_ID;
            break;
        case LLDPREMPORTIDSUBTYPE:      /* lldpRemPortIdSubtype */
        case LLDPREMPORTID:             /* lldpRemPortId  */
            Type = OHA_LLDP_TYPE_PORT_ID;
            break;
        case LLDPREMPORTDESC:           /* lldpRemPortDesc, IfDescr from IF-MIB  */
            Type = OHA_LLDP_TYPE_PORT_DESCR;
            break;
        case LLDPREMSYSNAME:            /* lldpRemSysName */
            Type = OHA_LLDP_TYPE_SYSTEM_NAME;
            break;
        case LLDPREMSYSDESC:            /* lldpRemSysDesc */
            Type = OHA_LLDP_TYPE_SYSTEM_DESCR;
            break;
        case LLDPREMSYSCAPSUPPORTED:        /* lldpRemSysCapSupported */
        case LLDPREMSYSCAPENABLED:          /* lldpRemSysCapEnabled   */
            Type = OHA_LLDP_TYPE_SYSTEM_CAP;
            break;
        default:
            Type = 0;
            RetVal = LSA_RET_ERR_PARAM;
            OHA_SNMPERROR("var_lldpRemObject(): Unknown magic number");
            break;
    }

    if (Type)
    {
        RetVal = oha_db_read_rem_lldp_element(NICId, (LSA_UINT16)(LowPortId + 1),
                                              (LSA_UINT16)(LowSenderId + 1),
                                              Type, &SubType, 0,
                                              &pVar, &Len);
    }

    OHA_FUNCTION_TRACE_01(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpRemObject(RetVal = 0x%X)", RetVal);
    return RetVal;
}


U_CHAR *  var_lldpRemEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
#define OHA_REM_ENTRY_OIDLEN     (11 + 1 + 1 + 1)  /* length of address table lldpRemEntry */

    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    static LSA_UINT8     byte_return =  0;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowIfId     = 0;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;

    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpRemEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    lowest[11] = 0; /* init. (reserved) lldpRemManAddrSubtype */
    lowest[13] = 0; /* init. (invalid) lldpRemIndex */
    current[9] = 0; /* init. (invalid) interface */

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (OHA_IS_NULL(pDB))
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpRemEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.4.1.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1; */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */

                current[vp->namelen + 1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* operation is GET_NEXT: caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN, lowest, OHA_REM_ENTRY_OIDLEN) < 0)))
                    {
                        LSA_UINT16 RetVal = var_lldpRemObject(pDB->NicId, vp, PortId, SenderId);

                        /* is the element existing anyway ? */
                        if (RetVal != LSA_RET_OK)
                        {
                            continue;
                        }

                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        switch (vp->magic)
        {
            case LLDPREMTIMEMARK:   /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL; /* FAIL return.*/
                }
                /* SYNTAX TimeFilter (RFC 2021):    */
                /* "To be used for the index to a table.  Allows an application   */
                /* to download only those rows changed since a particular time.   */
                /* A row is considered changed if the value of any object in the  */
                /* row changes or if the row is created or deleted.               */
                /* When sysUpTime is equal to zero, this table shall be empty.    */
                /* One entry exists for each past value of sysUpTime, except that */
                /* the whole table is purged should sysUpTime wrap.               */
                long_return = (LSA_INT32)lowest[11];
                return (U_CHAR*)&long_return;

                /* The index value used to identify the port component
                (contained in the local chassis with the LLDP agent)
                associated with this entry.  The lldpRemLocalPortNum
                identifies the port on which the remote system information
                is received. */
            case LLDPREMLOCALPORTNUM:       /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL; /* FAIL return.*/
                }
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* long_return =  LowPortId + 1; */
                long_return = (LSA_INT32)oha_snmp_get_port_id(LowIfId, LowPortId + 1);
                return (U_CHAR *)&long_return;

                /* "This object represents an arbitrary local integer value used by this
                agent to identify a particular connection instance, unique only for the
                indicated remote system. An agent is encouraged to assign monotonically
                increasing index values to new entries, starting with one, after each reboot.
                It is considered unlikely that the lldpRemIndex will wrap between reboots." */
            case LLDPREMINDEX:      /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL; /* FAIL return.*/
                }
                /* must be the table-index for GetNext access */
                /* long_return =  pRemoteSender->OidRemEntry.RemIndex; */
                long_return = (LSA_INT32)lowest[13];
                return (U_CHAR *)&long_return;

            case LLDPREMCHASSISIDSUBTYPE:       /* lldpRemChassisIdSubtype */
            {
				/* AP01234692: lldpRemChassisId   := LLDP_ChassisID */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_CHASSIS_ID,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    long_return = SubType;
                    return (U_CHAR*)&long_return;
                }
            }
            break;
            case LLDPREMCHASSISID:              /* lldpRemChassisId      */
            {
				/* AP01234692: lldpRemChassisId   := LLDP_ChassisID */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_CHASSIS_ID,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    *var_len = Len;
                    return (U_CHAR *)pVar;
                }
            }
            break;
            case LLDPREMPORTIDSUBTYPE:          /* lldpRemPortIdSubtype */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_PORT_ID,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    long_return = SubType;
                    return (U_CHAR*)&long_return;
                }
                break;
            case LLDPREMPORTID:                 /* lldpRemPortId    */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_PORT_ID,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    *var_len = Len;
                    return (U_CHAR *)pVar;
                }
                break;
            case LLDPREMPORTDESC:       /* lldpRemPortDesc, IfDescr from IF-MIB  */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_PORT_DESCR,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    *var_len = Len;
                    return (U_CHAR *)pVar;
                }
                break;
            case LLDPREMSYSNAME:                /* lldpRemSysName  */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_SYSTEM_NAME,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    *var_len = Len;
                    return (U_CHAR *)pVar;
                }
                break;
            case LLDPREMSYSDESC:                 /* lldpRemSysDesc   */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_SYSTEM_DESCR,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    *var_len = Len;
                    return (U_CHAR *)pVar;
                }
                break;
            case LLDPREMSYSCAPSUPPORTED:        /* lldpRemSysCapSupported */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_SYSTEM_CAP,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK &&
                    Len == LLDP_TLV_SYSTEM_CAP_SIZE )
                {
                    LSA_UINT16    SystemCapabilities;

                    OHA_ASSERT_NULL_PTR(pVar);
                    SystemCapabilities = OHA_GET16_NTOH (pVar, 0); /* 1st word */
                    byte_return = OHA_GetSystemCapabilitiesMap((LSA_UINT8)SystemCapabilities);

                    *var_len = 1;   /* SYNTAX: LldpSystemCapabilitiesMap (8 bits) */
                    return (U_CHAR *)&byte_return;
                }
                break;
            case LLDPREMSYSCAPENABLED:          /* lldpRemSysCapEnabled   */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 OHA_LLDP_TYPE_SYSTEM_CAP,
                                                 &SubType, 0,
                                                 &pVar, &Len) == LSA_RET_OK &&
                    Len == LLDP_TLV_SYSTEM_CAP_SIZE )
                {
                    LSA_UINT16    EnabledCapabilities;

                    OHA_ASSERT_NULL_PTR(pVar);
                    pVar += 2;    /* 2nd word */
                    EnabledCapabilities = OHA_GET16_NTOH (pVar, 0); /* 2nd word */
                    byte_return = OHA_GetSystemCapabilitiesMap((LSA_UINT8)EnabledCapabilities);

                    *var_len = 1; /* SYNTAX: LldpSystemCapabilitiesMap (8 bits) */
                    return (U_CHAR *)&byte_return;
                }
                break;
            default:
                OHA_SNMPERROR("var_lldpRemEntry(): Unknown magic number");
                break;
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpRemEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}

U_CHAR *  var_lldpRemManAddrEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face;
    LSA_UINT16 i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;

    LSA_BOOL Found = LSA_FALSE;

    LSA_UINT16 Len = 0;
    LLDP_PARAMS_MGM_ADDR_TYPE MgmAddr;
    LSA_UINT8  LenByte = 1; /* a lenbyte is to place before the ip address, see AP00285242 */

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpRemManAddrEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
                LSA_UINT8  SubType = 0xff;
                LSA_UINT16 LenTmp  = 0;     /* AP00285242 -> */

                /* create object id reflecting this lldpRemManAddrEntry table entry's */
                /* Oid: 1.0.8802.1.1.2.1.4.2.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex.lldpRemManAddrSubtype.lldpRemManAddr */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */

                /* current[vp->namelen] = (OHA_OID)PortId + 1; */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* read the remote ManAddr object, must be a lldp-sender of this object too */
                if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(PortId + 1), (LSA_UINT16)(SenderId + 1),
                                                 OHA_LLDP_TYPE_MGM_ADDR,
                                                 &SubType, 0,
                                                 &pVar, &LenTmp) != LSA_RET_OK)
                {
                    continue;
                }
                if (LenTmp == 0)
                {
                    continue;
                }

                MgmAddr.InterfaceNumberingSubtype = 0;
                MgmAddr.MgmtAddrStringLen = 0;
				MgmAddr.MgmtAddrSubtype   = 0;

                /* convert stream to MgmAddr params */
                if (OHA_LldpGetMgmAddr(pVar, (LSA_UINT32)LenTmp, &MgmAddr) != LSA_RET_OK)
                {
                    continue;
                }

                /* RQ 905029: Missing LldpRemManAddrOID entry (if OIDStringLen is 0) */
				if(!oper && MgmAddr.OIDStringLen == 0 && vp->magic == LLDPREMMANADDROID)
                {
                    /* note: TIA 3957404 too fixes RQ 4097408: Wrong lldpRemIndex (if OIDStringLen is 0) */
                    continue;
                }

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
				current[vp->namelen + 1] = pRemoteSender->OidRemEntry.RemIndex;


                /* set lldpRemManAddrSubType in objId */
                /* AP00736394: management address subtype (1 = IPv4,...) */

                current[vp->namelen+2] = (OHA_OID)MgmAddr.MgmtAddrSubtype;

                /* set lldpRemManAddr in objId */
                LenTmp = (LSA_UINT16)(MgmAddr.MgmtAddrStringLen - LLDP_TLV_MGM_ADDR_MGMT_ADDR_SUBTYPE_SIZE); /* StringLen = sizeof(Subtype + Address)  */
                pVar += LLDP_TLV_MGM_ADDR_MGMT_ADDR_STRING_LENGTH_SIZE + /* 1st octet:MgmtAddrStringLength */
                        LLDP_TLV_MGM_ADDR_MGMT_ADDR_SUBTYPE_SIZE;       /* 2nd octet: MgmtAddrSubtype     */

                /* copy length of management address into current (AP00736394) */
                if (LenByte)
                {
                    current[vp->namelen+2+1] = LenTmp; /* len = 4 if IPv4 is used */
                }

                /* copy management address into current. */
                {
                    OHA_COMMON_MEM_U8_PTR_TYPE cp = pVar;
                    LSA_UINT16 j;
                    for (j = (LSA_UINT16)(vp->namelen+3+LenByte); j < vp->namelen+3+LenByte+LenTmp; j++) /* current[12+LenByte]-current[15+LenByte] */
                        current[j] = *cp++;
                }
                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1+LenByte+LenTmp, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3+LenByte+LenTmp) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Len         = LenTmp;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1+LenByte+LenTmp, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1+LenByte+LenTmp, lowest, OHA_REM_ENTRY_OIDLEN+1+LenByte+LenTmp) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3+LenByte+LenTmp) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Len         = LenTmp;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+3+LenByte+Len) * sizeof(OHA_OID));
        *length = (vp->namelen+3+LenByte+Len);
        *var_len = sizeof long_return;   /* default return length */
        if (oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                         OHA_LLDP_TYPE_MGM_ADDR,
                                         &SubType, 0,
                                         &pVar, &Len) != LSA_RET_OK)
        {
            return LSA_NULL;
        }

        MgmAddr.MgmtAddrSubtype = 0;
        MgmAddr.MgmtAddrStringLen = 0;
        MgmAddr.InterfaceNumberingSubtype = 0;
        MgmAddr.InterfaceNumber = 0;
        MgmAddr.OIDStringLen = 0;

        /* convert stream to MgmAddr params */
        if (OHA_LldpGetMgmAddr(pVar, (LSA_UINT32)Len, &MgmAddr) != LSA_RET_OK)
        {
            return LSA_NULL;
        }

        switch (vp->magic)
        {
            case LLDPREMMANADDRSUBTYPE:     /* not-accessible */ /* mgmt addr subtype */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;   /* FAIL return.*/
                }
                long_return = MgmAddr.MgmtAddrSubtype;
                return (U_CHAR *)&long_return;

            case LLDPREMMANADDR:            /* not-accessible */ /* management address (IP,...) */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;   /* FAIL return.*/
                }
                *var_len = MgmAddr.MgmtAddrStringLen - LLDP_TLV_MGM_ADDR_MGMT_ADDR_SUBTYPE_SIZE; /* StringLen = sizeof(Subtype + Address)  */
                return (U_CHAR *)(pVar + LLDP_TLV_MGM_ADDR_MGMT_ADDR_STRING_LENGTH_SIZE + /* 1st octet:MgmtAddrStringLength */
                                  LLDP_TLV_MGM_ADDR_MGMT_ADDR_SUBTYPE_SIZE);       /* 2nd octet: MgmtAddrSubtype     */

            case LLDPREMMANADDRIFSUBTYPE:   /* interface numbering subtype (3 = port number) */
                long_return = MgmAddr.InterfaceNumberingSubtype;
                return (U_CHAR *)&long_return;

            case LLDPREMMANADDRIFID:        /* interface number (port id) */
                long_return = (LSA_INT32)MgmAddr.InterfaceNumber;
                return (U_CHAR *)&long_return;

            case LLDPREMMANADDROID:         /* remote AddrOID */
                if (MgmAddr.OIDStringLen && (MgmAddr.OIDStringLen <= LLDP_TLV_MGM_ADDR_MAX_OID_STRING_LEN)) /* 0 - 128 octets */
                {
                    static OHA_OID lldpManAddrOID[OHA_MAX_OID_LEN];
                    LSA_UINT    lldpManAddrOID_Len = OHA_MAX_OID_LEN;

                    /* oid from pdu */
                    (LSA_VOID) oha_asn1_to_objid(MgmAddr.OIDIdentifier, /* pointer to start of object */
                                                 MgmAddr.OIDStringLen,  /* number of coded bytes */
                                                 lldpManAddrOID,        /* pointer to start of OID buffer */
                                                 &lldpManAddrOID_Len);  /* IN/OUT - number of sub-id's in objid */

                    *var_len = (int)(lldpManAddrOID_Len * sizeof(OHA_OID));
                    return (U_CHAR *)&lldpManAddrOID;
                }
                break;
            default:
                OHA_SNMPERROR("var_lldpRemManAddrEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpRemManAddrEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpRemUnknownTLVEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 SenderId, PortId;
    OHA_DB_LLDP_ELEM_PTR_TYPE pLowElement = LSA_NULL;
	LSA_BOOL  HaveFound = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpRemUnknownTLVEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS && (!HaveFound); inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* find the entry for the table */
        for (PortId = 0; PortId < OHA_CFG_MAX_PORTS && (!HaveFound); PortId++)
        {
            for (SenderId = 0; SenderId < LLDP_MAX_PORT_SENDER && (!HaveFound); SenderId++)
            {
                OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];
                if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                    pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
                {
                    OHA_LIST_TYPED_ENTRY_TYPE(oha_db_lldp_elem_tag) * pAnchor;  /* Types 9 ... 126 */

                    pAnchor = oha_get_rem_lldp_db_element (pDB->NicId, (LSA_UINT16)(PortId+1), (LSA_UINT16)(SenderId+1), OHA_LLDP_TYPE_MGM_ADDR+1, 0, 0);
                    if (OHA_IS_NOT_NULL(pAnchor))       /* anchor exists */
                    {
                        OHA_DB_LLDP_ELEM_PTR_TYPE pElement = OhaListFirst(pAnchor, OHA_DB_LLDP_ELEM_PTR_TYPE);  /* starts with the first element */

                        /* create object id reflecting this lldpRemUnknownTLVEntry table entry's */
                        /* Oid: 1.0.8802.1.1.2.1.4.3.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex.lldpRemUnknownTLVType */

                        /* set lldpRemTimeMark in objId */
                        current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                        /* set lldpRemLocalPortNum in objId */
                        /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                        /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                        current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                        while (OHA_IS_NOT_NULL(pElement))
                        {
                            /* lldpRemIndex in objId */
                            /* it's the agents own index  */
                            current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                            /* set lldpRemUnknownTLVType in objId */
                            current[vp->namelen+2] = (OHA_OID)pElement->Type;

                            if (OHA_IS_NOT_NULL(pElement->pVariable) && pElement->Length)
                            {
                                /* element existing */
                                if (oper)   /* operation is SET or GET */
                                {
                                    if (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) == 0)
                                    {
                                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                                        pLowElement = pElement;
                                        HaveFound   = LSA_TRUE;   /* no need to search further */
										break;
                                    }
                                }
                                else     /* caller wants closest match */
                                {
                                    /* if new one is greater than input and closer to input than
                                     * previous lowest, save this one as the "next" one. */
                                    if ((oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) > 0) &&
                                        (OHA_IS_NULL(pLowElement) || (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+1, lowest, OHA_REM_ENTRY_OIDLEN+1) < 0)))
                                    {
                                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                                        pLowElement = pElement;
                                    }
                                }
                            }
                            pElement = OhaListNext(pAnchor, &pElement->ListElem, OHA_DB_LLDP_ELEM_PTR_TYPE);
                        }
                    }
                }
            }
        }
    }   /* end for inter_face loop */

    if (OHA_IS_NOT_NULL(pLowElement))  /* a match ? */
    {
        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
        *length = (vp->namelen+3);
        *var_len = sizeof long_return;   /* default return length */

        switch (vp->magic)
        {
            case LLDPREMUNKNOWNTLVTYPE: /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                long_return = pLowElement->Type;
                *var_len = sizeof(LSA_INT32);
                return (U_CHAR *)&long_return;

            case LLDPREMUNKNOWNTLVINFO:
                *var_len = pLowElement->Length;
                return (U_CHAR *)pLowElement->pVariable;

            default:
                OHA_SNMPERROR("var_lldpRemUnknownTLVEntry(): Unknown magic number");
                return LSA_NULL;
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpRemUnknownTLVEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpRemOrgDefInfoEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 SenderId, PortId;
    OHA_DB_LLDP_ELEM_PTR_TYPE pLowElement = LSA_NULL;
	LSA_BOOL  HaveFound = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpRemOrgDefInfoEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[18] = 0; /* init. (invalid) lldpRemIndex */
    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS && (!HaveFound); inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* find the entry for the table */
        for (PortId = 0; PortId < OHA_CFG_MAX_PORTS && (!HaveFound); PortId++)
        {
            for (SenderId = 0; SenderId < LLDP_MAX_PORT_SENDER && (!HaveFound); SenderId++)
            {
                OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];
                if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                    pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
                {
                    OHA_LIST_TYPED_ENTRY_TYPE(oha_db_lldp_elem_tag) * pAnchor;  /* Type 126 */

                    pAnchor = oha_get_rem_lldp_db_element (pDB->NicId, (LSA_UINT16)(PortId+1), (LSA_UINT16)(SenderId+1), OHA_LLDP_TYPE_ORG_SPECIFIC, 0, 0);
                    if (OHA_IS_NOT_NULL(pAnchor))       /* anchor exists */
                    {
                        OHA_DB_LLDP_ELEM_PTR_TYPE pElement = OhaListFirst(pAnchor, OHA_DB_LLDP_ELEM_PTR_TYPE);  /* starts with the first element */

                        /* create object id reflecting this lldpRemUnknownTLVEntry table entry's */
                        /* Oid: 1.0.8802.1.1.2.1.4.4.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex.
                                            .lldpRemOrgDefInfoOUI.lldpRemOrgDefInfoSubType.lldpRemOrgDefInfoIndex */

                        /* set lldpRemTimeMark in objId */
                        current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                        /* set lldpRemLocalPortNum in objId */
                        /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                        /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                        current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                        while (OHA_IS_NOT_NULL(pElement))
                        {
                            /* lldpRemIndex in objId */
                            /* it's the agents own index  */
                            current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                            /* set lldpRemOrgDefInfoOUI in objId */
                            {
                                OHA_COMMON_MEM_U8_PTR_TYPE cp = (OHA_COMMON_MEM_U8_PTR_TYPE)&pElement->OUI;
                                LSA_UINT16 i;
                                for (cp++, i = (LSA_UINT16)(vp->namelen+2); i < vp->namelen+2+LLDP_TLV_ORG_SPECIFIC_OUI_SIZE; i++)
                                    current[i] = *cp++;
                            }

                            /* set lldpRemOrgDefInfoSubType in objId */
                            current[vp->namelen+5] = (OHA_OID)pElement->SubType;

                            /* set lldpRemOrgDefInfoIndex in objId */
                            current[vp->namelen+6] = pRemoteSender->OidRemEntry.RemIndex;

                            if (OHA_IS_NOT_NULL(pElement->pVariable) && pElement->Length)
                            {
                                /* element existing */
                                if (oper)   /* operation is SET or GET */
                                {
                                    if (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+5, name, (unsigned)(*length)) == 0)
                                    {
                                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+7) * sizeof(OHA_OID));
                                        pLowElement = pElement;
                                        HaveFound = LSA_TRUE;   /* no need to search further */
										break;
                                    }
                                }
                                else     /* caller wants closest match */
                                {
                                    /* if new one is greater than input and closer to input than
                                     * previous lowest, save this one as the "next" one. */
                                    if ((oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+5, name, (unsigned)(*length)) > 0) &&
                                        (OHA_IS_NULL(pLowElement) || (oha_snmp_compare(current, OHA_REM_ENTRY_OIDLEN+5, lowest, OHA_REM_ENTRY_OIDLEN+5) < 0)))
                                    {
                                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+7) * sizeof(OHA_OID));
                                        pLowElement = pElement;
                                    }
                                }
                            }
                            pElement = OhaListNext(pAnchor, &pElement->ListElem, OHA_DB_LLDP_ELEM_PTR_TYPE);
                        }
                    }
                }
            }
        }
    }   /* end for inter_face loop */

    if (OHA_IS_NOT_NULL(pLowElement))  /* a match ? */
    {
        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+7) * sizeof(OHA_OID));
        *length = (vp->namelen+7);
        *var_len = sizeof long_return;   /* default return length */

        switch (vp->magic)
        {
            case LLDPREMORGDEFINFOOUI:  /* not-accessible */ /* lldpRemOrgDefInfoOUI     */
            {
                static LSA_UINT8 OUI[LLDP_TLV_ORG_SPECIFIC_MIN_SIZE];
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                OHA_PUT32_HTON (OUI, 0, (pLowElement->OUI << 8));
                *var_len = LLDP_TLV_ORG_SPECIFIC_OUI_SIZE;
                return (U_CHAR *)&OUI;
            }
            case LLDPREMORGDEFINFOSUBTYPE: /* not-accessible */ /* lldpRemOrgDefInfoSubtype */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                long_return = pLowElement->SubType;
                return (U_CHAR *)&long_return;

                /* "This object represents an arbitrary local integer value
                used by this agent to identify a particular unrecognized
                organizationally defined information instance, unique only
                for the lldpRemOrgDefInfoOUI and lldpRemOrgDefInfoSubtype
                from the same remote system.
                An agent is encouraged to assign monotonically increasing
                index values to new entries, starting with one, after each
                reboot.  It is considered unlikely that the
                lldpRemOrgDefInfoIndex will wrap between reboots." */
            case LLDPREMORGDEFINFOINDEX: /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                /* long_return =  pRemoteSender->OidRemEntry.RemIndex; */
                long_return = (LSA_INT32)lowest[18];
                return (U_CHAR *)&long_return;

            case LLDPREMORGDEFINFO:                 /* lldpRemOrgDefInfo     */
                *var_len = pLowElement->Length;
                return (U_CHAR *)pLowElement->pVariable;

            default:
                OHA_SNMPERROR("var_lldpRemOrgDefInfoEntry(): Unknown magic number");
                break;
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpRemOrgDefInfoEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}


U_CHAR *  var_lldpXPnoConfigEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;
    LSA_UINT16 PortCnt;
    unsigned   port_id = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXPnoConfigEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoConfigEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt) /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpLocPortEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoConfigEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    if (oper == SET_OP)  /* force range checking on sets */
    {
		LSA_UINT32 mib_option;
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

        oha_set_parms.do_range = LSA_TRUE;
        oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
        oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;

        switch (vp->magic)
        {
	        case LLDPXPNOCONFIGSPDTXENABLE:
				mib_option  = OHA_CTRL_PNO_DELAY;
                break;
			case LLDPXPNOCONFIGPORTSTATUSTXENABLE:
				mib_option  = OHA_CTRL_PNO_PORT_STATUS;
                break;
			case LLDPXPNOCONFIGALIASTXENABLE:
				mib_option  = OHA_CTRL_PNO_ALIAS;
                break;
			case LLDPXPNOCONFIGMRPTXENABLE:
				mib_option  = OHA_CTRL_PNO_MRP;
				break;
			case LLDPXPNOCONFIGPTCPTXENABLE:
				mib_option  = OHA_CTRL_PNO_PTCP;
				break;
            default:
                oha_set_parms.do_range = LSA_FALSE;
			    return LSA_NULL;
        }

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)port_id, mib_option, &mib_var_val, LSA_NULL);

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)port_id, mib_option, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		OHA_ASSERT(mib_option);
		OHA_ASSERT_NULL_PTR(mib_var_val);

		oha_stats_info.PortOptions[inter_face-1][port_id-1] |= mib_option;

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoConfigEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXPNOCONFIGSPDTXENABLE:       /* lldpXPnoConfigSPDTxEnable  */
            /* signal line delay TLV transmission */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_PNO_DELAY,
													  &TxEnable, LSA_NULL, LSA_NULL);
            return (U_CHAR *)&TxEnable;

        case LLDPXPNOCONFIGPORTSTATUSTXENABLE:    /* lldpXPnoConfigPortStatusTxEnable  */
            /* RT port status TLV transmission */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_PNO_PORT_STATUS,
													  &TxEnable, LSA_NULL, LSA_NULL);
            return (U_CHAR *)&TxEnable;

        case LLDPXPNOCONFIGALIASTXENABLE:         /* lldpXPnoConfigAliasTxEnable  */
            /* alias TLV (chassisId) transmission */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_PNO_ALIAS,
													  &TxEnable, LSA_NULL, LSA_NULL);
            return (U_CHAR *)&TxEnable;

        case LLDPXPNOCONFIGMRPTXENABLE:           /* lldpXPnoConfigMrpTxEnable */
            /* MRP TLV transmission */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_PNO_MRP,
													  &TxEnable, LSA_NULL, LSA_NULL);
            return (U_CHAR *)&TxEnable;

        case LLDPXPNOCONFIGPTCPTXENABLE:          /* lldpXPnoConfigPtcpTxEnable */
            /* PTCP TLV transmission */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_PNO_PTCP,
													  &TxEnable, LSA_NULL, LSA_NULL);
            return (U_CHAR *)&TxEnable;

        default:
            OHA_SNMPERROR("var_lldpXPnoConfigEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoConfigEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}

U_CHAR *  var_lldpXPnoLocEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    LSA_UINT16 PortCnt;
    static LSA_INT32  long_return =  0L;
    static LSA_UINT8  MRP_Nil_UUID[sizeof(OHA_UUID_TYPE)];
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
    LSA_UINT8  SubType;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXPnoLocEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoLocEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt) /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoLocEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoLocEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    switch (vp->magic)
    {
        case LLDPXPNOLOCLPDVALUE:         /* lldpXPnoLocLPDValue  */
            /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
            SubType = OHA_LLDP_SUB_TYPE_PNO_DELAY;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
            {
                long_return = (LSA_INT32)OHA_LLDP_GET_U32(NamePtr+(OHA_LLDP_IDX_CABLEDELAY_LOC*sizeof(LSA_UINT32)));
            }
            else
            {
                long_return =  0L;
            }
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
            *var_len = sizeof(long_return);

            return (U_CHAR *)NamePtr;

        case LLDPXPNOLOCPORTTXDVALUE:     /* lldpXPnoLocPortTxDValue */
            /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
            SubType = OHA_LLDP_SUB_TYPE_PNO_DELAY;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
            {
                long_return = (LSA_INT32)OHA_LLDP_GET_U32(NamePtr+(OHA_LLDP_IDX_TXDELAY_LOC * sizeof(LSA_UINT32)));
            }
            else
            {
                long_return =  0L;
            }
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
            *var_len = sizeof(long_return);

            return (U_CHAR *)NamePtr;

        case LLDPXPNOLOCPORTRXDVALUE:     /* lldpXPnoLocPortRxDValue */
            /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
            SubType = OHA_LLDP_SUB_TYPE_PNO_DELAY;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
            {
                long_return = (LSA_INT32)OHA_LLDP_GET_U32(NamePtr);
            }
            else
            {
                long_return =  0L;
            }
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
            *var_len = sizeof(long_return);

            return (U_CHAR *)NamePtr;

        case LLDPXPNOLOCPORTSTATUSRT2:    /* lldpXPnoLocPortStatusRT2 */
            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
            {
                /* oha_pdu_get_u16 (long_return, NamePtr); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0); /* 1st word */

                /* Bit 2 - 15: RTClass2_PortStatus.reserved */
                /* This field shall be set according to 3.6.3.2. */
                long_return &= (LSA_INT32)OHA_PORT_STATUS_CLASS2_MASK;
            }
            else
            {
                long_return =  0L;
            }
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
            *var_len = sizeof(long_return);

            return (U_CHAR *)NamePtr;

        case LLDPXPNOLOCPORTSTATUSRT3:    /* lldpXPnoLocPortStatusRT3 */
            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
            {
                NamePtr += 2;   /* 2nd word */
                long_return = 0L;
                /* oha_pdu_get_u16 (long_return, NamePtr);  */
                long_return = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0); /* 2nd word */


                /* Bit 3 - 14: RTClass3_PortStatus.reserved */
                /* This field shall be set according to the */
                /* Convention for the encoding of reserved bits and octets */
                long_return &= (LSA_INT32)OHA_PORT_STATUS_CLASS3_MASK;
            }
            else
            {
                long_return =  0L;
            }
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
            *var_len = sizeof(long_return);

            return (U_CHAR *)NamePtr;

        case LLDPXPNOLOCPORTNOS:  /* lldpXPnoLocPortNoS */
        {
            LSA_INT RetLen = OHA_DB_READ_STATION_NAME(pDB->NicId, &NamePtr);

            if (RetLen)    /* chassisname present, take the MAC-Addr */
            {
                *var_len = RetLen;
                return (U_CHAR *)NamePtr;
            }

            RetLen = OHA_DB_READ_MAC_ADDR(pDB->NicId, &NamePtr);
            if (RetLen == OHA_MAC_ADDR_SIZE)    /* MAC-Addr present */
            {
                static LSA_UINT8 MacStr[OHA_MAC2A_LEN+1];
                *var_len  = oha_mac2a (NamePtr, (OHA_COMMON_MEM_U8_PTR_TYPE)&MacStr);
                return (U_CHAR *)&MacStr;
            }
        }
        return LSA_NULL;    /* default FAIL return.*/

        case LLDPXPNOLOCPORTMRPUUID:  /* lldpXPnoLocPortMrpUuId */
        {
            OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));

            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS_MRP;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (!(OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_MRP_SIZE)))
            {
                NamePtr = MRP_Nil_UUID;
            }

            *var_len = sizeof(OHA_UUID_TYPE);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTMRRTSTATUS:  /* lldpXPnoLocPortMrrtStatus */
        {
            long_return =  0L;
            return (U_CHAR *)&long_return;
        }

        /* PTCP_MasterSourceAddress, PTCP_SubdomainUUID, IRDataUUID */
        case LLDPXPNOLOCPORTPTCPMASTER:  /* lldpXPnoLocPortPtcpMaster */
        {
            OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));

            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (!(OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
            {
                NamePtr = MRP_Nil_UUID;
            }

            *var_len = sizeof(OHA_MAC_TYPE);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTPTCPSUBDOMAINUUID:  /* lldpXPnoLocPortPtcpSubdomainUUID */
        {
            OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));

            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (!(OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
            {
                NamePtr = MRP_Nil_UUID;
            }
            else
            {
                NamePtr += OHA_MAC_ADDR_SIZE;
            }

            *var_len = sizeof(OHA_UUID_TYPE);
            return (U_CHAR *)(NamePtr);
        }

        case LLDPXPNOLOCPORTPTCPIRDATAUUID:  /* lldpXPnoLocPortPtcpIRDataUUID */
        {
            OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));

            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (!(OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
            {
                NamePtr = MRP_Nil_UUID;
            }
            else
            {
                NamePtr += (OHA_MAC_ADDR_SIZE + OHA_UUID_SIZE);
            }

            *var_len = sizeof(OHA_UUID_TYPE);
            return (U_CHAR *)(NamePtr);
        }

        case LLDPXPNOLOCPORTMODERT3:  /* lldpXPnoLocPortModeRT3 */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
            {
                LSA_UINT16 RTClass3_PortStatus;

                NamePtr += 2;   /* 2nd word */
                /* oha_pdu_get_u16 (long_return, NamePtr);  */
                RTClass3_PortStatus = OHA_GET16_NTOH (NamePtr, 0); /* 2nd word */

                /* Bit 15: RTClass3_PortStatus.Mode */
                /* 0x00  STANDARD   Use all states of irt port statemachine  */
                /* 0x01  OPTIMIZED  Use optimized states of irt port state machine */
                RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_MODE_MASK;

                long_return = (RTClass3_PortStatus) ? 0L : 1L;
            }
            else
            {
                long_return = 1L; /* standard */
            }
            *var_len = sizeof(long_return);
            return (U_CHAR *)&long_return;
        }

        case LLDPXPNOLOCPORTPERIODLENGTH: /* lldpXPnoLocPortPeriodLength */
        {
            /* AP01528425: Get the LengthOfPeriod from the database !         */
            /* In case of class2 operation there is no LLDP object PtcpStatus */
            long_return = (LSA_INT32)pDB->LengthOfPeriod;

            *var_len = sizeof(long_return);
            return (U_CHAR *)&long_return;
        }

        case LLDPXPNOLOCPORTPERIODVALIDITY:   /* lldpXPnoLocPortPeriodValidity */
        {
            long_return = (LSA_INT32)pDB->LengthOfPeriod;
            if (long_return)
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTREDOFFSET:    /* lldpXPnoLocPortRedOffset */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+sizeof(LSA_UINT32), 0);
                long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
            }
            else
            {
                long_return =  0L;
            }
            *var_len = sizeof(long_return);
            return (U_CHAR *)&long_return;
        }

        case LLDPXPNOLOCPORTREDVALIDITY:  /* lldpXPnoLocPortRedValidity */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+sizeof(LSA_UINT32), 0);
                long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                NamePtr  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                           (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTORANGEOFFSET: /* lldpXPnoLocPortOrangeOffset */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+2*sizeof(LSA_UINT32), 0);
                long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
            }
            else
            {
                long_return =  0L;
            }
            *var_len = sizeof(long_return);
            return (U_CHAR *)&long_return;
        }

        case LLDPXPNOLOCPORTORANGEVALIDITY:   /* lldpXPnoLocPortOrangeValidity */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+2*sizeof(LSA_UINT32), 0);
                long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                NamePtr  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                           (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTGREENOFFSET:  /* lldpXPnoLocPortGreenOffset */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+3*sizeof(LSA_UINT32), 0);
                long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
            }
            else
            {
                long_return =  0L;
            }
            *var_len = sizeof(long_return);
            return (U_CHAR *)&long_return;
        }

        case LLDPXPNOLOCPORTGREENVALIDITY:    /* lldpXPnoLocPortGreenValidity */
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
            {
                NamePtr += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr+3*sizeof(LSA_UINT32), 0);
                long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                NamePtr  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                           (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTSTATUSRT3OPTIMIZATIONSUPPORTED:    /* former lldpXPnoLocPortStatusRT3Optimized */
        {
            NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value; /* always FALSE */
            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENINGSUPPORTED:
        {
            NamePtr  = (OHA_EDD_PREAMBLE_SHORTENING_SUPPORTED(pDB->HardwareType)) ?
						(OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
						(OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;

            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATIONSUPPORTED:
        {
            NamePtr  = (OHA_EDD_FRAGMENTATION_SUPPORTED(pDB->HardwareType)) ?
						(OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
						(OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;

            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTSTATUSRT3PREAMBLESHORTENING:
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
            {
                LSA_UINT16 RTClass3_PortStatus;

                NamePtr += 2;   /* 2nd word */
                RTClass3_PortStatus = OHA_GET16_NTOH (NamePtr, 0); /* 2nd word */

				/* Bit 13: RTClass3_PortStatus.PreambleLength     */
                RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_PREAMBLE_MASK;

                NamePtr = (RTClass3_PortStatus) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                           (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }

            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        case LLDPXPNOLOCPORTSTATUSRT3FRAGMENTATION:
        {
            SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
            (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                                   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                   &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                   &NamePtr, &Len);
            if (OHA_IS_NOT_NULL(NamePtr) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
            {
                LSA_UINT16 RTClass3_PortStatus;

                NamePtr += 2;   /* 2nd word */
                RTClass3_PortStatus = OHA_GET16_NTOH (NamePtr, 0); /* 2nd word */

				/* Bit 12: RTClass3_PortStatus.Fragmentation      */
                RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_FRAGMENTATION_MASK;

                NamePtr = (RTClass3_PortStatus) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                           (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            else    /* return FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }

            *var_len = sizeof(oha_en_TruthValue[1].value);
            return (U_CHAR *)NamePtr;
        }

        default:
            OHA_SNMPERROR("var_lldpXPnoLocEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoLocEntry() - FAIL return");
    return LSA_NULL; /* default FAIL return.*/
}

U_CHAR *  var_lldpXPnoRemEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
#define OHA_XREM_ENTRY_OIDLEN     (14 + 1 + 1 + 1)  /* length of address table lldpXPnoRemSPDEntry */

    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32  long_return =  0L;
    static LSA_UINT8  MRP_Nil_UUID[sizeof(OHA_UUID_TYPE)];
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;
    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXPnoRemEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXPnoRemSPDEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.3791.1.3.1.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        switch (vp->magic)
        {
            case LLDPXPNOREMLPDVALUE:       /* lldpXPnoRemLPDValue  */
                /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
                SubType  = OHA_LLDP_SUB_TYPE_PNO_DELAY;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                                       (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
                {               /* what the remote says */
                    long_return = (LSA_INT32)OHA_LLDP_GET_U32(pVar+(OHA_LLDP_IDX_CABLEDELAY_LOC * sizeof(LSA_UINT32)));
                }
                else
                {
                    long_return =  0L;
                }
                pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
                *var_len = sizeof(long_return);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTTXDVALUE:   /* lldpXPnoRemPortTxDValue */
                /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
                SubType  = OHA_LLDP_SUB_TYPE_PNO_DELAY;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
                {               /* what the remote says */
                    long_return = (LSA_INT32)OHA_LLDP_GET_U32(pVar+(OHA_LLDP_IDX_TXDELAY_LOC * sizeof(LSA_UINT32)));
                }
                else
                {
                    long_return =  0L;
                }
                pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
                *var_len = sizeof(long_return);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTRXDVALUE:   /* lldpXPnoRemPortRxDValue */
                /* read from LLDP-DB (RxDelayLoc, RxDelayRem, TxDelayLoc, TxDelayRem, CableDelay) */
                SubType  = OHA_LLDP_SUB_TYPE_PNO_DELAY;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_DELAY_SIZE))
                {
                    long_return = (LSA_INT32)OHA_LLDP_GET_U32(pVar);
                }
                else
                {
                    long_return =  0L;
                }
                /* what the remote station says */
                pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
                *var_len = sizeof(long_return);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTSTATUSRT2:  /* lldpXPnoRemPortStatusRT2 */
                SubType  = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
                {
                    /* oha_pdu_get_u16 (long_return, pVar); */
                    long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0); /* 1st word */

                    /* Bit 2 - 15: RTClass2_PortStatus.reserved */
                    /* This field shall be set according to 3.6.3.2. */
                    long_return &= (LSA_INT32)OHA_PORT_STATUS_CLASS2_MASK;
                }
                else
                {
                    long_return = OHA_RTCLASS2_OFF;
                }
                pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
                *var_len = sizeof(long_return);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTSTATUSRT3:  /* lldpXPnoRemPortStatusRT3 */
                SubType  = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
                {
                    pVar += 2;  /* 1st word */
                    long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0); /* 2nd word */

                    /* Bit 3 - 15: RTClass3_PortStatus.reserved */
                    /* This field shall be set according to the */
                    /* Convention for the encoding of reserved bits and octets */
                    long_return &= (LSA_INT32)OHA_PORT_STATUS_CLASS3_MASK;
                }
                else
                {
                    long_return = OHA_PORT_STATUS_CLASS3_OFF;
                }
                pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return;
                *var_len = sizeof(long_return);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTNOS:    /* lldpXPnoRemPortNoS */
                /* lldpRemChassisId      */
                SubType  = 0;
                if (oha_db_read_rem_chassis_name(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                 &SubType,
                                                 &pVar, &Len) == LSA_RET_OK)
                {
                    if (SubType != OHA_CHASSIS_ID_MAC_ADDR)
                    {
                    	if(Len != 0)
                    	{
                            *var_len = Len;
                            return (U_CHAR *)pVar;
                        }

                        /* nameless, read remote MAC for the MIB */
                        SubType = OHA_LLDP_SUB_TYPE_PNO_CHASSIS_MAC_ADR;
                        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1),
                                                               OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                               &pVar, &Len);
                    }
                    if (Len == OHA_MAC_ADDR_SIZE)   /* MAC-Address */
                    {
                        static LSA_UINT8 MacStr[OHA_MAC2A_LEN+1];
                        *var_len  = oha_mac2a (pVar, (OHA_COMMON_MEM_U8_PTR_TYPE)&MacStr);
                        return (U_CHAR *)&MacStr;
                    }
                }
                return(LSA_NULL);   /* FAIL return.*/

            case LLDPXPNOREMPORTMRPUUID:  /* lldpXPnoRemPortMrpUuId */
            {
                OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));
                SubType  = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS_MRP;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (!(OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_MRP_SIZE)))
                {
                    pVar = MRP_Nil_UUID;
                }

                *var_len = sizeof(OHA_UUID_TYPE);
                return (U_CHAR *)pVar;
            }

            case LLDPXPNOREMPORTMRRTSTATUS:  /* lldpXPnoRemPortMrrtStatus */

                SubType  = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS_MRP;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_MRP_SIZE))
                {
                    long_return = (LSA_INT32)OHA_GET16_NTOH (pVar + sizeof(OHA_UUID_TYPE), 0); /* behind MRP_DomainUUID */
                }
                else
                {
                    long_return =  0L;
                }
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTPTCPMASTER:  /* lldpXPnoRemPortPtcpMaster */

                OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (!(OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
                {
                    pVar = MRP_Nil_UUID;
                }

                *var_len = sizeof(OHA_MAC_TYPE);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTPTCPSUBDOMAINUUID:  /* lldpXPnoRemPortPtcpSubdomainUUID */

                OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));
                SubType  = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (!(OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
                {
                    pVar = MRP_Nil_UUID;
                }
                else
                {
                    pVar += OHA_MAC_ADDR_SIZE;
                }

                *var_len = sizeof(OHA_UUID_TYPE);
                return (U_CHAR *)(pVar);

            case LLDPXPNOREMPORTPTCPIRDATAUUID:  /* lldpXPnoRemPortPtcpIRDataUUID */

                OHA_MEMSET(MRP_Nil_UUID, 0, sizeof(OHA_UUID_TYPE));
                SubType  = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (!(OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE)))
                {
                    pVar = MRP_Nil_UUID;
                }
                else
                {
                    pVar += (OHA_MAC_ADDR_SIZE + OHA_UUID_SIZE);
                }

                *var_len = sizeof(OHA_UUID_TYPE);
                return (U_CHAR *)(pVar);

            case LLDPXPNOREMPORTMODERT3:  /* lldpXPnoRemPortModeRT3 */

                SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
                {
                    LSA_UINT16 RTClass3_PortStatus;

                    pVar += 2;  /* 2nd word */
                    /* oha_pdu_get_u16 (long_return, pVar); */
                    RTClass3_PortStatus = OHA_GET16_NTOH (pVar, 0); /* 2nd word */

                    /* Bit 15: RTClass3_PortStatus.Mode */
                    /* 0x00  STANDARD   Use all states of irt port statemachine  */
                    /* 0x01  OPTIMIZED  Use optimized states of irt port state machine */
                    RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_MODE_MASK;

                    long_return = (RTClass3_PortStatus) ? 0L : 1L;
                }
                else
                {
                    long_return = 1L;   /* standard */
                }
                *var_len = sizeof(long_return);
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTPERIODLENGTH: /* lldpXPnoRemPortPeriodLength */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar, 0);
                    long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
                }
                else
                {
                    long_return =  0L;
                }
                *var_len = sizeof(long_return);
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTPERIODVALIDITY:   /* lldpXPnoRemPortPeriodValidity */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar, 0);
                    long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                    pVar  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTREDOFFSET:    /* lldpXPnoRemPortRedOffset */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+sizeof(LSA_UINT32), 0);
                    long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
                }
                else
                {
                    long_return =  0L;
                }
                *var_len = sizeof(long_return);
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTREDVALIDITY:  /* lldpXPnoRemPortRedValidity */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+sizeof(LSA_UINT32), 0);
                    long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                    pVar  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTORANGEOFFSET: /* lldpXPnoRemPortOrangeOffset */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+2*sizeof(LSA_UINT32), 0);
                    long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
                }
                else
                {
                    long_return =  0L;
                }
                *var_len = sizeof(long_return);
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTORANGEVALIDITY:   /* lldpXPnoRemPortOrangeValidity */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+2*sizeof(LSA_UINT32), 0);
                    long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                    pVar  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTGREENOFFSET:  /* lldpXPnoRemPortGreenOffset */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+3*sizeof(LSA_UINT32), 0);
                    long_return &= ~(LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* clear bit */
                }
                else
                {
                    long_return =  0L;
                }
                *var_len = sizeof(long_return);
                return (U_CHAR *)&long_return;

            case LLDPXPNOREMPORTGREENVALIDITY:    /* lldpXPnoRemPortGreenValidity */
                SubType = OHA_LLDP_SUB_TYPE_PNO_PTCP_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PTCP_STATUS_SIZE))
                {
                    pVar += OHA_MAC_ADDR_SIZE+OHA_UUID_SIZE+OHA_UUID_SIZE;
                    long_return = (LSA_INT32)OHA_GET32_NTOH (pVar+3*sizeof(LSA_UINT32), 0);
                    long_return &= (LSA_INT32)OHA_SYNC_PERIOD_VALID_MASK; /* get bit */
                    pVar  = (long_return) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTSTATUSRT3PREAMBLESHORTENING:  /* lldpXPnoRemPortStatusRT3PreambleShortening */

                SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
                {
                    LSA_UINT16 RTClass3_PortStatus;

                    pVar += 2;  /* 2nd word */
                    RTClass3_PortStatus = OHA_GET16_NTOH (pVar, 0); /* 2nd word */

					/* Bit 13: RTClass3_PortStatus.PreambleLength     */
                    RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_PREAMBLE_MASK;

                    pVar  = (RTClass3_PortStatus) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }

                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            case LLDPXPNOREMPORTSTATUSRT3FRAGMENTATION:  /* lldpXPnoRemPortStatusRT3Fragmentation */

                SubType = OHA_LLDP_SUB_TYPE_PNO_PORT_STATUS;
                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId,
                                                       (LSA_UINT16)(LowPortId + 1), (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_PNO,
                                                       &pVar, &Len);
                if (OHA_IS_NOT_NULL(pVar) && (Len == OHA_LLDP_PNO_PORT_STATUS_SIZE))
                {
                    LSA_UINT16 RTClass3_PortStatus;

                    pVar += 2;  /* 2nd word */
                    RTClass3_PortStatus = OHA_GET16_NTOH (pVar, 0); /* 2nd word */

					/* Bit 12: RTClass3_PortStatus.Fragmentation      */
                    RTClass3_PortStatus &= OHA_PORT_STATUS_CLASS3_FRAGMENTATION_MASK;

                    pVar  = (RTClass3_PortStatus) ? (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value :
                            (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                else    /* return FALSE */
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }

                *var_len = sizeof(oha_en_TruthValue[1].value);
                return (U_CHAR *)pVar;

            default:
                OHA_SNMPERROR("var_lldpXPnoRemEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXPnoRemEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3PortConfigEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face;
    unsigned   port;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_UINT8    byte_return = 0;
	LSA_UINT32 TxEnable = OHA_DOT3_TLVS_TX_DISABLE;
    LSA_UINT16 PortCnt;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3PortConfigEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3PortConfigEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)    /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3PortConfigEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3PortConfigEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    if (oper == SET_OP)  /* force range checking on sets */
    {
		LSA_UINT32 mib_option;
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

        oha_set_parms.do_range = LSA_TRUE;
        oha_set_parms.hi_range = OHA_DOT3_TLVS_TX_ENABLE;
        oha_set_parms.lo_range = OHA_DOT3_TLVS_TX_DISABLE;
		oha_set_parms.vbflags |= SF_NOASCIICHK;				/* AP01319680 */

        switch (vp->magic)
        {
	        case LLDPXDOT3PORTCONFIGTLVSTXENABLE:
				mib_option = OHA_CTRL_DOT3_TLVS;
				*var_len = 1;   /* SYNTAX:  (4 bits) */
                break;
            default:
                oha_set_parms.do_range = LSA_FALSE;
			    return LSA_NULL;
        }

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)port_id, mib_option, &mib_var_val, LSA_NULL);

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)port_id, mib_option, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		OHA_ASSERT(mib_option);
		OHA_ASSERT_NULL_PTR(mib_var_val);

		oha_stats_info.PortOptions[inter_face-1][port_id-1] |= mib_option;

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3PortConfigEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXDOT3PORTCONFIGTLVSTXENABLE:       /* lldpXdot3PortConfigEnable  */
            *var_len = 1;		/* SYNTAX BITS {
									macPhyConfigStatus (0),
									powerViaMDI (1),
									linkAggregation (2),
									maxFrameSize (3) }  */
															   /* is send allowed ? */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_DOT3_TLVS,
													  &TxEnable, LSA_NULL, LSA_NULL);
			byte_return = (LSA_UINT8)TxEnable;
	        return (U_CHAR *)&byte_return;

        default:
            OHA_SNMPERROR("var_lldpXdot3PortConfigEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3PortConfigEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3LocPortEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    LSA_UINT16 PortCnt;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32 long_return =  0L;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
    LSA_UINT8  SubType;


    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3LocPortEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPortEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPortEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPortEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    SubType  = LLDP_TLV_IEEE_802_3_TYPE_MAC_PHY_CFG_STATUS;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                           &NamePtr, &Len);
    switch (vp->magic)
    {
        case LLDPXDOT3LOCPORTAUTONEGSUPPORTED:
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_MAUT_TYPE_SIZE))
            {
                if ((*NamePtr) & LLDP_TLV_MAC_PHY_AUTONEG_SUPPORTED)
                {
                    NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
            }
            else        /* default: FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[0].value);
            return (U_CHAR *)NamePtr;

        case LLDPXDOT3LOCPORTAUTONEGENABLED:        /* lldpXdot3LocPortAutoNegEnable  */
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_MAUT_TYPE_SIZE))
            {
                if ((*NamePtr) & LLDP_TLV_MAC_PHY_AUTONEG_ENABLED)
                {
                    NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
            }
            else        /* default: FALSE */
            {
                NamePtr  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[0].value);
            return (U_CHAR *)NamePtr;

        case LLDPXDOT3LOCPORTAUTONEGADVERTISEDCAP:
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_MAUT_TYPE_SIZE))
            {
                NamePtr += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE;
            }
            else
            {
                long_return = 0;
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&long_return; /* 0 */
            }
            *var_len = LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE;
            return (U_CHAR *)NamePtr;

        case LLDPXDOT3LOCPORTOPERMAUTYPE:
        {
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE +
                 LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_MAUT_TYPE_SIZE))
            {
                NamePtr += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE;
                NamePtr += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE;
                /* oha_pdu_get_u16(long_return, NamePtr); */
                long_return = (LSA_INT32)OHA_GET16_NTOH(NamePtr, 0);
            }
            else
            {
                long_return = 0;
            }
        }
        return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot3LocPortEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPortEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3LocPowerEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    LSA_UINT16 PortCnt;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32 long_return =  0L;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
    LSA_UINT8  SubType;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3LocPowerEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPowerEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPowerEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPowerEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    SubType  = LLDP_TLV_IEEE_802_3_TYPE_POWER_VIA_MDI;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                           &NamePtr, &Len);

    /* return 0, if power via MDI is not supported */
    if (OHA_IS_NULL(NamePtr) ||
        (Len != (LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE +
                 LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_PAIR_SIZE +
                 LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_CLASS_SIZE)))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPowerEntry() - VLAN Name invalid");
        return(LSA_NULL);
    }

    switch (vp->magic)
    {
        case LLDPXDOT3LOCPOWERPORTCLASS:
            if ((*NamePtr) & LLDP_TLV_MDI_POWER_PORT_CLASS_PSE) /* 1 = PSE */
            {
                long_return = 1;    /* ASN_INTEGER { pClassPSE(1), pClassPD(2) } */
            }
            else                    /* 0 = FD  */
            {
                long_return = 2;
            }
            return (U_CHAR *)&long_return;

        case  LLDPXDOT3LOCPOWERMDISUPPORTED:
            if ((*NamePtr) & LLDP_TLV_MDI_POWER_SUPPORTED)
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
            }
            else
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[0].value);
            return (U_CHAR *)NamePtr;

        case  LLDPXDOT3LOCPOWERMDIENABLED:
            if ((*NamePtr) & LLDP_TLV_MDI_POWER_ENABLED)
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
            }
            else
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[0].value);
            return (U_CHAR *)NamePtr;

        case  LLDPXDOT3LOCPOWERPAIRCONTROLABLE:
            if ((*NamePtr) & LLDP_TLV_MDI_POWER_CONTROLABLE)
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
            }
            else
            {
                NamePtr = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
            }
            *var_len = sizeof(oha_en_TruthValue[0].value);
            return (U_CHAR *)NamePtr;

        case  LLDPXDOT3LOCPOWERPAIRS:
            NamePtr += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE;
            /* oha_pdu_get_u8(long_return, NamePtr); */
            long_return = (LSA_INT32)OHA_GET8_NTOH (NamePtr, 0);
            return (U_CHAR *)&long_return;

        case  LLDPXDOT3LOCPOWERCLASS:
            NamePtr += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE;
            NamePtr += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_PAIR_SIZE;
            /* oha_pdu_get_u8(long_return, NamePtr); */
            long_return = (LSA_INT32)OHA_GET8_NTOH (NamePtr, 0);
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot3LocPowerEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocPowerEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3LocLinkAggEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    LSA_UINT16 PortCnt;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32    long_return =  0L;
    static LSA_UINT8    byte_return = 0;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
    LSA_UINT8  SubType;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3LocLinkAggEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocLinkAggEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocLinkAggEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocLinkAggEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    SubType  = LLDP_TLV_IEEE_802_3_TYPE_LINK_AGGREGATION;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                           &NamePtr, &Len);
    switch (vp->magic)
    {
        case LLDPXDOT3LOCLINKAGGSTATUS:
            /* return 0, if link aggregation is not supported */
            if (OHA_IS_NULL(NamePtr) ||
                (Len != (LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_STATUS_SIZE +
                         LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_PORT_ID_SIZE)) )
            {
                byte_return = 0;
            }
            else
            {
                /* oha_pdu_get_u8(long_return, NamePtr); */
                byte_return = OHA_GET8_NTOH (NamePtr, 0);
            }
            *var_len = 1;   /* SYNTAX:  (2 bits) */
            return (U_CHAR *)&byte_return;

        case LLDPXDOT3LOCLINKAGGPORTID:
            /* return 0, if link aggregation is not supported */
            if (OHA_IS_NULL(NamePtr) ||
                (Len != (LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_STATUS_SIZE +
                         LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_PORT_ID_SIZE)) )
            {
                long_return =  0L;
            }
            else
            {
                NamePtr += LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_STATUS_SIZE;
                /* oha_pdu_get_u32(long_return, NamePtr); */
                long_return = (LSA_INT32)OHA_GET32_NTOH (NamePtr, 0);
            }
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot3LocLinkAggEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocLinkAggEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3LocMaxFrameSizeEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32 long_return =  0L;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len     = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3LocMaxFrameSizeEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocMaxFrameSizeEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0; /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)    /* nothing found */
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocMaxFrameSizeEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (!pDB)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocMaxFrameSizeEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    SubType  = LLDP_TLV_IEEE_802_3_TYPE_MAX_FRAME_SIZE;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                           &NamePtr, &Len);
    switch (vp->magic)
    {
        case LLDPXDOT3LOCMAXFRAMESIZE:
            /* return EDD_IEEE_FRAME_LENGTH, if no entry for maximum frame size */
            if (OHA_IS_NULL(NamePtr) ||
                (Len != (LLDP_TLV_IEEE_802_3_MAX_FRAME_SIZE_FRAME_SIZE_SIZE)) )
            {
                long_return = EDD_IEEE_FRAME_LENGTH_WITH_CRC; /* EDD_IEEE_FRAME_LENGTH+4 */
            }
            else
            {
                /* oha_pdu_get_u16(long_return, NamePtr); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0);
            }
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot3LocMaxFrameSizeEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3LocMaxFrameSizeEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3RemPortEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3RemPortEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXdot3RemPortEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.4623.1.3.1.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */


    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_3_TYPE_MAC_PHY_CFG_STATUS;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                               &pVar, &Len);

        if (!(OHA_IS_NOT_NULL(pVar) &&
              (Len == LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE +
               LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE +
               LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_MAUT_TYPE_SIZE)))
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemPortEntry() - MAC/PHY Status invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT3REMPORTAUTONEGSUPPORTED:
                if ((*pVar) & LLDP_TLV_MAC_PHY_AUTONEG_SUPPORTED)
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[0].value);
                return (U_CHAR *)pVar;

            case LLDPXDOT3REMPORTAUTONEGENABLED:        /* lldpXdot3RemPortAutoNegEnable  */
                if ((*pVar) & LLDP_TLV_MAC_PHY_AUTONEG_ENABLED)
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    pVar  = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[0].value);
                return (U_CHAR *)pVar;

            case LLDPXDOT3REMPORTAUTONEGADVERTISEDCAP:
                pVar += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE;
                *var_len = LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE;
                return (U_CHAR *)pVar;

            case LLDPXDOT3REMPORTOPERMAUTYPE:
                pVar += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_SS_SIZE;
                pVar += LLDP_TLV_IEEE_802_3_MAC_PHY_CFG_STATUS_ANEG_AC_SIZE;
                /* oha_pdu_get_u16(long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0);
                return (U_CHAR *)&long_return;

            default:
                OHA_SNMPERROR("var_lldpXdot3RemPortEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemPortEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3RemPowerEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3RemPowerEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXdot3RemPowerEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.4623.1.3.2.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */


    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_3_TYPE_POWER_VIA_MDI;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                               &pVar, &Len);

        /* return 0, if power via MDI is not supported */
        if (OHA_IS_NULL(pVar) ||
            (Len != (LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE +
                     LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_PAIR_SIZE +
                     LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_CLASS_SIZE)))
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemPowerEntry() - power via MDI invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT3REMPOWERPORTCLASS:
                if ((*pVar) & LLDP_TLV_MDI_POWER_PORT_CLASS_PSE)    /* 1 = PSE */
                {
                    long_return = 1;    /* ASN_INTEGER { pClassPSE(1), pClassPD(2) } */
                }
                else                    /* 0 = FD  */
                {
                    long_return = 2;
                }
                return (U_CHAR *)&long_return;

            case  LLDPXDOT3REMPOWERMDISUPPORTED:
                if ((*pVar) & LLDP_TLV_MDI_POWER_SUPPORTED)
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[0].value);
                return (U_CHAR *)pVar;

            case  LLDPXDOT3REMPOWERMDIENABLED:
                if ((*pVar) & LLDP_TLV_MDI_POWER_ENABLED)
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[0].value);
                return (U_CHAR *)pVar;

            case  LLDPXDOT3REMPOWERPAIRCONTROLABLE:
                if ((*pVar) & LLDP_TLV_MDI_POWER_CONTROLABLE)
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[0].value;
                }
                else
                {
                    pVar = (OHA_COMMON_MEM_U8_PTR_TYPE)&oha_en_TruthValue[1].value;
                }
                *var_len = sizeof(oha_en_TruthValue[0].value);
                return (U_CHAR *)pVar;

            case  LLDPXDOT3REMPOWERPAIRS:
                pVar += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE;
                /* oha_pdu_get_u8(long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET8_NTOH (pVar, 0);
                return (U_CHAR *)&long_return;

            case  LLDPXDOT3REMPOWERCLASS:
                pVar += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_SUPPORT_SIZE;
                pVar += LLDP_TLV_IEEE_802_3_POWER_VIA_MDI_POWER_PAIR_SIZE;
                /* oha_pdu_get_u8(long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET8_NTOH (pVar, 0);
                return (U_CHAR *)&long_return;

            default:
                OHA_SNMPERROR("var_lldpXdot3RemPowerEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemPowerEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}


U_CHAR *  var_lldpXdot3RemLinkAggEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32    long_return =  0L;
    static LSA_UINT8    byte_return = 0;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3RemLinkAggEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this LldpXdot3RemLinkAggEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.4623.1.3.3.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */


    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_3_TYPE_LINK_AGGREGATION;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                               &pVar, &Len);

        /* return 0, if link aggregation is not supported */
        if (OHA_IS_NULL(pVar) ||
            (Len != (LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_STATUS_SIZE +
                     LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_PORT_ID_SIZE)))
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemLinkAggEntry() - link aggregation invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT3REMLINKAGGSTATUS:
                /* oha_pdu_get_u8(byte_return, pVar); */
                byte_return = OHA_GET8_NTOH (pVar, 0);
                *var_len = 1;   /* SYNTAX:  (2 bits) */
                return (U_CHAR *)&byte_return;

            case LLDPXDOT3REMLINKAGGPORTID:
                pVar += LLDP_TLV_IEEE_802_3_LINK_AGGREGATION_STATUS_SIZE;
                /* oha_pdu_get_u32(long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET32_NTOH (pVar, 0);
                return (U_CHAR *)&long_return;

            default:
                OHA_SNMPERROR("var_lldpXdot3RemLinkAggEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemLinkAggEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot3RemMaxFrameSizeEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot3RemMaxFrameSizeEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXdot3RemMaxFrameSizeEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.4623.1.3.4.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_3_TYPE_MAX_FRAME_SIZE;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_3,
                                               &pVar, &Len);

        /* return 0, if maximum frame size is not supported */
        if (OHA_IS_NULL(pVar) ||
            (Len != LLDP_TLV_IEEE_802_3_MAX_FRAME_SIZE_FRAME_SIZE_SIZE))
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemMaxFrameSizeEntry() - link aggregation invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT3REMMAXFRAMESIZE:
                /* oha_pdu_get_u16(long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0);
                return (U_CHAR *)&long_return;

            default:
                OHA_SNMPERROR("var_lldpXdot3RemMaxFrameSizeEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot3RemMaxFrameSizeEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}


U_CHAR *  var_lldpXdot1ConfigPortVlanEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32 long_return =  0L;
    LSA_UINT16 PortCnt;
	LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1ConfigPortVlanEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigPortVlanEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigPortVlanEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (OHA_IS_NULL(pDB))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigPortVlanEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    if (oper == SET_OP)  /* force range checking on sets */
    {
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

		switch (vp->magic)
		{
			case LLDPXDOT1CONFIGPORTVLANTXENABLE:
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
                oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;
			break;
			default:
				OHA_SNMPERROR("var_lldpXdot1ConfigPortVlanEntry(): Unknown magic number");
		}

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_DOT1_VLAN_ID, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.PortOptions[inter_face-1][port_id-1] |= OHA_CTRL_DOT1_VLAN_ID;

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_DOT1_VLAN_ID, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigPortVlanEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXDOT1CONFIGPORTVLANTXENABLE:         /* lldpXdot1ConfigPortVlanTxEnable  */
            /* return FALSE, VLAN is not supported */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)port_id, OHA_CTRL_DOT1_VLAN_ID,
													  &TxEnable, LSA_NULL, LSA_NULL);
			long_return = (LSA_INT32)TxEnable;
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot1ConfigPortVlanEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigPortVlanEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1ConfigVlanNameEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    static LSA_INT32 long_return =  0L;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;
	LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1ConfigVlanNameEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigVlanNameEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173577: Index = PortNum + VlanId  */
		/* get the VlanId from the database */
		SubType  = LLDP_TLV_IEEE_802_1_TYPE_VLAN_NAME;
		(LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
											   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
											   &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
											   &NamePtr, &Len);
		/* 0, if VLAN is not supported */
		if (OHA_IS_NULL(NamePtr) ||
			(Len > (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
					LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
					LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MAX_VLAN_NAME_LEN) ||
			 (Len < (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
					 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
					 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MIN_VLAN_NAME_LEN))))
		{
			current[15] = 0;
		}
		else
		{
			current[15] = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0);  /* VlanId (1st word) */
		}

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    if (oper == SET_OP)  /* force range checking on sets */
    {
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

		switch (vp->magic)
		{
			case LLDPXDOT1CONFIGVLANNAMETXENABLE:
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
                oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;
			break;
			default:
				OHA_SNMPERROR("var_lldpXdot1ConfigVlanNameEntry(): Unknown magic number");
		}

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_VLAN_NAME, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.PortOptions[low_if-1][low_port-1] |= OHA_CTRL_DOT1_VLAN_NAME;

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_VLAN_NAME, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigVlanNameEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXDOT1CONFIGVLANNAMETXENABLE:         /* lldpXdot1ConfigVlanNameEntry  */
            /* return FALSE, VLAN is not supported */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_VLAN_NAME,
													  &TxEnable, LSA_NULL, LSA_NULL);
			long_return = (LSA_INT32)TxEnable;
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot1ConfigVlanNameEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigVlanNameEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1ConfigProtoVlanEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    static LSA_INT32 long_return =  0L;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;
	LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1ConfigProtoVlanEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtoVlanEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173577: Index = PortNum + ProtoVlanId  */
		/* get the ProtoVlanId from the database */
		SubType  = LLDP_TLV_IEEE_802_1_TYPE_PPVID;
		(LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
											   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
											   &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
											   &NamePtr, &Len);
		if (OHA_IS_NOT_NULL(NamePtr) &&
			(Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
		{
			current[15] = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 1); /* ProtoVlanId (2nd byte) */
		}
		else
		{
			current[15] = 0; /* 0, if VLAN is not supported */
		}

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    if (oper == SET_OP)  /* force range checking on sets */
    {
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

		switch (vp->magic)
		{
			case LLDPXDOT1CONFIGPROTOVLANTXENABLE:
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
                oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;
			break;
			default:
				OHA_SNMPERROR("var_lldpXdot1ConfigProtoVlanEntry(): Unknown magic number");
		}

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTO_VLAN, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.PortOptions[low_if-1][low_port-1] |= OHA_CTRL_DOT1_PROTO_VLAN;

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTO_VLAN, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtoVlanEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXDOT1CONFIGPROTOVLANTXENABLE:        /* lldpXdot1ConfigProtoVlanEntry  */
            /* return FALSE, VLAN is not supported */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTO_VLAN,
													  &TxEnable, LSA_NULL, LSA_NULL);
			long_return = (LSA_INT32)TxEnable;
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot1ConfigProtoVlanEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtoVlanEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1ConfigProtocolEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    static LSA_INT32 long_return =  0L;
    LSA_UINT16 PortCnt;
	LSA_UINT32 TxEnable = OHA_LLDP_TX_DISABLE;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1ConfigProtocolEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtocolEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173520: Index = PortNum + ProtocolIndex  */
		/* IEEE Std 802.1AB-2005: "There may be multiple protocols, identified by particular
		    lldpXdot1ProtocolIndex, and lldpLocPortNum." */
		current[15] = 1; /* one ProtocolIndex := 1 only, SYNTAX Integer32 (1..2147483647) */

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    if (oper == SET_OP)  /* force range checking on sets */
    {
		OHA_COMMON_MEM_U32_PTR_TYPE  mib_var_val = 0; /* return the set value to write to */
		LSA_UINT8  AccessControl = OHA_NO_ACCESS;

		if(vp->acl != OHA_SNMP_RWRITE)  /* SET operation not supported */
		{
		    return LSA_NULL;
		}

		switch (vp->magic)
		{
			case LLDPXDOT1CONFIGPROTOCOLTXENABLE:
		        oha_set_parms.do_range = LSA_TRUE;
                oha_set_parms.hi_range = OHA_LLDP_TX_DISABLE;
                oha_set_parms.lo_range = OHA_LLDP_TX_ENABLE;
			break;
			default:
				OHA_SNMPERROR("var_lldpXdot1ConfigProtocolEntry(): Unknown magic number");
		}

		(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_ACCESS(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTOCOL, &AccessControl);
		if (AccessControl == OHA_NO_ACCESS || AccessControl == OHA_READ_ONLY)
		{
            return LSA_NULL;              /* not supported */
		}

		oha_stats_info.PortOptions[low_if-1][low_port-1] |= OHA_CTRL_DOT1_PROTOCOL;

		(LSA_VOID)oha_db_read_temp_lldp_mib_port_value(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTOCOL, &mib_var_val, LSA_NULL);

		OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtocolEntry() - PARSE SET return");
        return (U_CHAR *)mib_var_val;
	}

    switch (vp->magic)
    {
        case LLDPXDOT1CONFIGPROTOCOLTXENABLE:         /* lldpXdot1ConfigProtocolEntry  */
            /* return FALSE, VLAN is not supported */
			(LSA_VOID)OHA_DB_READ_LLDP_MIB_PORT_VALUE(pDB->NicId, (LSA_UINT16)low_port, OHA_CTRL_DOT1_PROTOCOL,
													  &TxEnable, LSA_NULL, LSA_NULL);
			long_return = (LSA_INT32)TxEnable;
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot1ConfigProtocolEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1ConfigProtocolEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1LocEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32     long_return =  0L;
    OHA_OID newname[OHA_MAX_NAME_LEN];
    unsigned   inter_face, port;
    unsigned   port_id = 0;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1LocEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    newname[9] = 0;  /* init. (invalid) interface */
    OHA_MEMCPY((char *)newname, (char *)vp->name, vp->namelen * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        int   result;
        newname[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);
        result = oha_snmp_compare(name, (unsigned)(*length), newname, vp->namelen);
        if ((oper && (result == 0)) || (!oper && (result < 0)))
            break;
    }

    if (port >= PortCnt)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocEntry() - no such port");
        return(LSA_NULL);
    }

    inter_face = oha_snmp_get_if_id(port+1, &port_id);
    OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
    OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

    pDB = OHA_GetIf((LSA_UINT16)(inter_face));
    if (OHA_IS_NULL(pDB))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocEntry() - no such interface");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)newname, vp->namelen * sizeof(OHA_OID));
    *length = vp->namelen;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    SubType  = LLDP_TLV_IEEE_802_1_TYPE_PORT_VLAN_ID;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                           &pVar, &Len);
    switch (vp->magic)
    {
        case LLDPXDOT1LOCPORTVLANID:      /* lldpXdot1LocEntry  */
            if (OHA_IS_NOT_NULL(pVar) && (Len == LLDP_TLV_IEEE_802_1_PORT_VLAN_IDENTIFIER_SIZE))
            {
                /* oha_pdu_get_u16 (long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0); /* 1st word */
            }

            /* return 0, if VLAN is not supported */
            return (U_CHAR *)&long_return;

        default:
            OHA_SNMPERROR("var_lldpXdot1LocEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1LocProtoVlanEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32  long_return =  0L;
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1LocProtoVlanEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocProtoVlanEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173520: Index = PortNum + ProtoVlanId  */
		/* get the ProtoVlanId from the database */
		SubType  = LLDP_TLV_IEEE_802_1_TYPE_PPVID;
		(LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
											   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
											   &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
											   &NamePtr, &Len);
		if (OHA_IS_NOT_NULL(NamePtr) &&
			(Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
		{
			current[15] = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 1); /* ProtoVlanId (2nd byte) */
		}
		else
		{
			current[15] = 0; /* 0, if VLAN is not supported */
		}

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    /* get the ProtoVlanId from the database */
    SubType  = LLDP_TLV_IEEE_802_1_TYPE_PPVID;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(low_port), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                           &NamePtr, &Len);
    switch (vp->magic)
    {
        case LLDPXDOT1LOCPROTOVLANID: /* lldpXdot1LocEntry  *//* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
            /* return 0, if VLAN is not supported */
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
            {
                NamePtr += 1;
                /* oha_pdu_get_u16 (long_return, NamePtr); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0); /* 1st word */
            }
            else
            {
                long_return = 0;
            }
            return (U_CHAR *)&long_return;

        case LLDPXDOT1LOCPROTOVLANSUPPORTED:
            /* return FALSE, VLAN is not supported */
            *var_len = sizeof(oha_en_TruthValue[1].value);
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
            {
                if ((*NamePtr) & 0x01)  /* 1st word */
                {
                    return (U_CHAR *)&oha_en_TruthValue[0].value;
                }
            }
            return (U_CHAR *)&oha_en_TruthValue[1].value;

        case LLDPXDOT1LOCPROTOVLANENABLED:
            /* return FALSE, VLAN is not supported */
            *var_len = sizeof(oha_en_TruthValue[1].value);
            if (OHA_IS_NOT_NULL(NamePtr) &&
                (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
            {
                if ((*NamePtr) & 0x02)  /* 1st word */
                {
                    return (U_CHAR *)&oha_en_TruthValue[0].value;
                }
            }
            return (U_CHAR *)&oha_en_TruthValue[1].value;

        default:
            OHA_SNMPERROR("var_lldpXdot1LocProtoVlanEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocProtoVlanEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1LocVlanNameEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32  long_return =  0L;
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1LocVlanNameEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocVlanNameEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173577: Index = PortNum + VlanId  */
		/* get the VlanId from the database */
		SubType  = LLDP_TLV_IEEE_802_1_TYPE_VLAN_NAME;
		(LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
											   (LSA_UINT16)(port_id), OHA_LLDP_TYPE_ORG_SPECIFIC,
											   &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
											   &NamePtr, &Len);
		/* 0, if VLAN is not supported */
		if (OHA_IS_NULL(NamePtr) ||
			(Len > (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
					LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
					LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MAX_VLAN_NAME_LEN) ||
			 (Len < (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
					 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
					 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MIN_VLAN_NAME_LEN))))
		{
			current[15] = 0;
		}
		else
		{
			current[15] = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0);  /* VlanId (1st word) */
		}

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    /* get the VlanId from the database */
    SubType  = LLDP_TLV_IEEE_802_1_TYPE_VLAN_NAME;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(low_port), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                           &NamePtr, &Len);

    /* return 0, if VLAN is not supported */
    if (OHA_IS_NULL(NamePtr) ||
        (Len > (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
                LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MAX_VLAN_NAME_LEN) ||
         (Len < (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
                 LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MIN_VLAN_NAME_LEN))))
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocVlanNameEntry() - VLAN Name invalid");
        return(LSA_NULL);
    }

    switch (vp->magic)
    {
        case LLDPXDOT1LOCVLANID: /* lldpXdot1LocVlanNameEntry  *//* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
            /* oha_pdu_get_u16 (long_return, NamePtr); */
            long_return = (LSA_INT32)OHA_GET16_NTOH (NamePtr, 0); /* 1st word */
            return (U_CHAR *)&long_return;

        case LLDPXDOT1LOCVLANNAME:
            NamePtr += LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE;
            /* oha_pdu_get_u8 (long_return, NamePtr); */
            long_return = (LSA_INT32)OHA_GET8_NTOH (NamePtr, 0); /* next byte is VLAN name length */

            if (Len == long_return + LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE)
            {
                *var_len = (int)long_return;
            }
            else    /* return NULL, if VLAN is not supported */
            {
                NamePtr  = LSA_NULL;
            }
            return (U_CHAR *)NamePtr;

        default:
            OHA_SNMPERROR("var_lldpXdot1LocVlanNameEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocVlanNameEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1LocProtocolEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    static LSA_INT32  long_return =  0L;
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */
    OHA_OID   current[OHA_MAX_NAME_LEN];

    unsigned   inter_face, port_id = 0;
    unsigned   port;
    OHA_DB_IF_PTR_TYPE   pDB;
    OHA_COMMON_MEM_U8_PTR_TYPE NamePtr = LSA_NULL;
    LSA_UINT16 Len = 0;
    LSA_UINT8  SubType;
    LSA_UINT16 PortCnt;
    unsigned low_if = 0;	/* lowest entry we'll find */
    unsigned low_port = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1LocProtocolEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

    PortCnt = oha_snmp_count_if_ports();
    if (PortCnt == 0)
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocProtocolEntry() - no interface");
        return(LSA_NULL);
    }

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    lowest[14] = 0;
    current[9] = 0;  /* init. (invalid) interface */

    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    /* find "next" port */
    for (port = 0; port < PortCnt; port++)
    {
        current[14/*OidLen-1*/] = (OHA_OID)((U_LONG)port + 1);

		inter_face = oha_snmp_get_if_id(port+1, &port_id);
		OHA_ASSERT(inter_face && (inter_face <= OHA_CFG_MAX_NICS));
		OHA_ASSERT(port_id && (port_id <= OHA_CFG_MAX_PORTS));

		pDB = OHA_GetIf((LSA_UINT16)(inter_face));
		if (OHA_IS_NULL(pDB))    /* if this entry isn't valid */
		{
			continue;
		}

		/* AP01173520: Index = PortNum + ProtocolIndex  */
		/* IEEE: There may be multiple protocols, identified by particular
			lldpXdot1ProtocolIndex, and lldpLocPortNum." */
		current[15] = 1; /* we take one ProtocolIndex only, SYNTAX Integer32 (1..2147483647) */

		if (oper)   /* operation is SET or GET */
		{
			if (oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) == 0)
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
				break;   /* no need to search further */
			}
		}
		else     /* caller wants closest match */
		{
			/* if new one is greater than input and closer to input than
			 * previous lowest, save this one as the "next" one. */
			if ((oha_snmp_compare(current, 15+1, name, (unsigned)(*length)) > 0) &&
				(!low_if || (oha_snmp_compare(current, 15+1, lowest, 15+1) < 0)))
			{
				OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
				low_if = inter_face;
				low_port = port_id;
			}
		}
    }   /* end for lldp_mib loop */

    if (!low_if)
    {
        return(LSA_NULL); /* no match */
    }

    pDB = OHA_GetIf((LSA_UINT16)(low_if));
	OHA_ASSERT_NULL_PTR(pDB);

    SubType  = LLDP_TLV_IEEE_802_1_TYPE_PROTOCOL_IDENTITY;
    (LSA_VOID)oha_db_read_loc_lldp_element(pDB->NicId,
                                           (LSA_UINT16)(low_port), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                           &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                           &NamePtr, &Len);

    /* return 0, if VLAN is not supported */
    if (OHA_IS_NULL(NamePtr) ||
        (Len > (LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_LENGTH_SIZE +
                LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_MAX_LEN)) ||
        (Len < (LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_LENGTH_SIZE +
                LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_MIN_LEN)) )
    {
        OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocProtocolEntry() - VLAN Name invalid");
        return(LSA_NULL);
    }

    OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+1) * sizeof(OHA_OID));
    *length = vp->namelen + 1;
    *var_len = sizeof(LSA_INT32);   /* default to 32 bit return */

    switch (vp->magic)
    {
        case LLDPXDOT1LOCPROTOCOLINDEX: /* lldpXdot1LocProtocolEntry  *//* not-accessible */
            if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
            {
                return LSA_NULL;    /* FAIL return.*/
            }
            long_return = 1;             /* oly one */
            return (U_CHAR *)&long_return;

        case LLDPXDOT1LOCPROTOCOLID:
            /* oha_pdu_get_u8 (long_return, NamePtr); */
            long_return = (LSA_INT32)OHA_GET8_NTOH (NamePtr, 0);   /* next byte is protocol ID */
            if (Len == long_return + LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_LENGTH_SIZE)
            {
                *var_len = (int)long_return;
            }
            else    /* return NULL, if VLAN is not supported */
            {
                NamePtr  = LSA_NULL;
            }
            return (U_CHAR *)NamePtr;

        default:
            OHA_SNMPERROR("var_lldpXdot1LocProtocolEntry(): Unknown magic number");
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1LocProtocolEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1RemEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1RemEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXdot1RemEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.32962.1.3.1.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN, lowest, OHA_XREM_ENTRY_OIDLEN) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+2) * sizeof(OHA_OID));
        *length = (vp->namelen+2);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_1_TYPE_PORT_VLAN_ID;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                               &pVar, &Len);
        switch (vp->magic)
        {
            case LLDPXDOT1REMPORTVLANID:        /* lldpXdot1RemEntry  */
                if (OHA_IS_NOT_NULL(pVar) && (Len == LLDP_TLV_IEEE_802_1_PORT_VLAN_IDENTIFIER_SIZE))
                {
                    /* oha_pdu_get_u16 (long_return, NamePtr); */
                    long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0); /* 1st word */
                }
                else
                {
                    long_return = 0;
                }

                /* return 0, if VLAN is not supported */
                return (U_CHAR *)&long_return;

            default:
                OHA_SNMPERROR("var_lldpXdot1RemEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1RemProtoVlanEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,           /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_BOOL Found = LSA_FALSE;

    OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
    LSA_UINT16 Len = 0;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1RemProtoVlanEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                OHA_COMMON_MEM_U8_PTR_TYPE pVarTmp = LSA_NULL;
                LSA_UINT16 LenTmp  = 0;
                LSA_UINT8  SubType = LLDP_TLV_IEEE_802_1_TYPE_PPVID;
                LSA_UINT16 VLanID;

                /* create object id reflecting this lldpXdot1RemProtoVlanEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.32962.1.3.2.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex.lldpXdot1RemProtoVlanId */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(PortId + 1),
                                                       (LSA_UINT16)(SenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                                       &pVarTmp, &LenTmp);

                if (OHA_IS_NOT_NULL(pVar) &&
                    (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
                {
                    /* oha_pdu_get_u16 (long_return, pVar+1); */
                    VLanID = OHA_GET16_NTOH ((pVar+1), 0); /* 1st word */
                }
                else            /* 0, if VLAN is not supported */
                {
                    VLanID = 0;
                }

                /* set lldpXdot1RemProtoVlanId in objId */
                current[vp->namelen+2] = (OHA_OID)VLanID;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        Len         = LenTmp;
                        pVar        = pVarTmp;
                        Found       = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, lowest, OHA_XREM_ENTRY_OIDLEN+1) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        Len         = LenTmp;
                        pVar        = pVarTmp;
                        Found       = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
        *length = (vp->namelen+3);
        *var_len = sizeof long_return;   /* default return length */

        switch (vp->magic)
        {
            case LLDPXDOT1REMPROTOVLANID: /* lldpXdot1RemEntry  */ /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                /* return 0, if VLAN is not supported */
                if (OHA_IS_NOT_NULL(pVar) &&
                    (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
                {
                    pVar += 1;
                    /* oha_pdu_get_u16 (long_return, pVar); */
                    long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0); /* 1st word */
                }
                return (U_CHAR *)&long_return;

            case LLDPXDOT1REMPROTOVLANSUPPORTED:
                /* return FALSE, VLAN is not supported */
                *var_len = sizeof(oha_en_TruthValue[1].value);
                if (OHA_IS_NOT_NULL(pVar) &&
                    (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
                {
                    if ((*pVar) & LLDP_TLV_PPVID_CAPABLE)   /* 1st word */
                    {
                        return (U_CHAR *)&oha_en_TruthValue[0].value;
                    }
                }
                return (U_CHAR *)&oha_en_TruthValue[1].value;

            case LLDPXDOT1REMPROTOVLANENABLED:
                /* return FALSE, VLAN is not supported */
                *var_len = sizeof(oha_en_TruthValue[1].value);
                if (OHA_IS_NOT_NULL(pVar) &&
                    (Len == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
                {
                    if ((*pVar) & LLDP_TLV_PPVID_ENABLED)   /* 1st word */
                    {
                        return (U_CHAR *)&oha_en_TruthValue[0].value;
                    }
                }
                return (U_CHAR *)&oha_en_TruthValue[1].value;

            default:
                OHA_SNMPERROR("var_lldpXdot1RemProtoVlanEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemProtoVlanEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1RemVlanNameEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1RemVlanNameEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                OHA_COMMON_MEM_U8_PTR_TYPE pVarTmp = LSA_NULL;
                LSA_UINT16 LenTmp  = 0;
                LSA_UINT8  SubType = LLDP_TLV_IEEE_802_1_TYPE_PPVID;
                LSA_UINT16 VLanID;

                /* create object id reflecting this lldpXdot1RemVlanNameEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.32962.1.3.3.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(PortId + 1),
                                                       (LSA_UINT16)(SenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                                       &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                                       &pVarTmp, &LenTmp);

                if (OHA_IS_NOT_NULL(pVarTmp) &&
                    (LenTmp == LLDP_TLV_IEEE_802_1_PPVID_FLAGS_SIZE + LLDP_TLV_IEEE_802_1_PPVID_REFERENCE_NUMBER_SIZE))
                {
                    /* oha_pdu_get_u16 (long_return, pVar+1); */
                    VLanID = OHA_GET16_NTOH ((pVarTmp+1), 0); /* 1st word */
                }
                else            /* 0, if VLAN is not supported */
                {
                    VLanID = 0;
                }

                /* set lldpXdot1RemProtoVlanId in objId */
                current[vp->namelen+2] = (OHA_OID)VLanID;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, lowest, OHA_XREM_ENTRY_OIDLEN+1) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
        *length = (vp->namelen+3);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_1_TYPE_VLAN_NAME;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                               &pVar, &Len);

        /* return 0, if VLAN is not supported */
        if (OHA_IS_NULL(pVar) ||
            (Len > (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                    LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
                    LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MAX_VLAN_NAME_LEN)) ||
            (Len < (LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                    LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE +
                    LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_MIN_VLAN_NAME_LEN)))
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemVlanNameEntry() - VLAN Name invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT1REMVLANID: /* lldpXdot1RemVlanNameEntry  */ /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                /* oha_pdu_get_u16 (long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET16_NTOH (pVar, 0);  /* 1st word */
                return (U_CHAR *)&long_return;

            case LLDPXDOT1REMVLANNAME:
                pVar += LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE;
                /* oha_pdu_get_u8 (long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET8_NTOH (pVar, 0); /* next byte is VLAN name length */

                if (Len == long_return + LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_ID_SIZE +
                    LLDP_TLV_IEEE_802_1_PORT_VLAN_NAME_VLAN_NAME_LEN_SIZE)
                {
                    *var_len = (int)long_return;
                }
                else    /* return NULL, if VLAN is not supported */
                {
                    pVar  = LSA_NULL;
                }
                return (U_CHAR *)pVar;

            default:
                OHA_SNMPERROR("var_lldpXdot1RemVlanNameEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemVlanNameEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

U_CHAR *  var_lldpXdot1RemProtocolEntry(
    struct snmp_variable * vp,  /* IN - pointer to variables[] entry */
    OHA_OID * name,     /* IN/OUT - input name requested; output name found */
    int *   length,     /* IN/OUT - length of input & output oids */
    int oper,       /* IN - NEXT_OP (=0), GET_OP (=1), or SET_OP (=-1) */
    int *   var_len)    /* OUT - length of variable, or 0 if function */
{
    OHA_OID   current[OHA_MAX_NAME_LEN];
    OHA_OID   lowest[OHA_MAX_NAME_LEN];        /* "best fit" object Id */

    unsigned   inter_face, i;
    static LSA_INT32     long_return =  0L;
    OHA_DB_IF_PTR_TYPE   pDB;
    LSA_UINT16 LowSenderId = 0;
    LSA_UINT16 LowPortId   = 0;
    LSA_UINT16 LowIfId     = 0;
    LSA_BOOL Found = LSA_FALSE;

    OHA_FUNCTION_TRACE_05(0, LSA_TRACE_LEVEL_CHAT,
                          "IN : var_lldpXdot1RemProtocolEntry(vp: 0x%X, name: 0x%X, length: 0x%X, oper: 0x%X, var_len: 0x%X)",
                          vp, name, length, oper, var_len);

	OHA_ASSERT_NULL_PTR(length);
	OHA_ASSERT_NULL_PTR(vp);
	OHA_ASSERT_NULL_PTR(var_len);

    current[9] = 0; /* init. (invalid) interface */
    /* fill in object part of name for current (less sizeof instance part) */
    OHA_MEMCPY((char *)current, (char *)vp->name, (LSA_UINT32)DEF_VARLEN * sizeof(OHA_OID));

    for (inter_face = 1; inter_face <= OHA_CFG_MAX_NICS; inter_face++)
    {
        pDB = OHA_GetIf((LSA_UINT16)(inter_face));
        if (!pDB)
        {
            break;
        }

        /* scan at table for closest match */
        for (i = 0; i < (OHA_CFG_MAX_PORTS * LLDP_MAX_PORT_SENDER); i++)
        {
            LSA_UINT16 SenderId = (LSA_UINT16)(i % LLDP_MAX_PORT_SENDER);
            LSA_UINT16 PortId   = (LSA_UINT16)(i / LLDP_MAX_PORT_SENDER);
            OHA_LLDP_SENDER_PTR_TYPE pRemoteSender = &pDB->LldpData[PortId].RemoteSender[SenderId];

            if (pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_VALID ||
                pRemoteSender->SnmpSenderStatus == OHA_STATUS_DATA_INVALID)
            {
                /* create object id reflecting this lldpXdot1RemProtocolEntry table entry's lldpRemTimeMark & lldpRemLocalPortNum */
                /* Oid: 1.0.8802.1.1.2.1.5.32962.1.3.4.1.row.lldpRemTimeMark.lldpRemLocalPortNum.lldpRemIndex.lldpXdot1RemProtocolIndex */

                /* set lldpRemTimeMark in objId */
                current[vp->namelen-1] = (OHA_OID)pRemoteSender->OidRemEntry.RemTimeMark;

                /* set lldpRemLocalPortNum in objId */
                /* we store 'em 0 thru n-1, snmp wants 1 thru n */
                /* current[vp->namelen] = (OHA_OID)PortId + 1;  */
                current[vp->namelen] = (OHA_OID)oha_snmp_get_port_id(inter_face, PortId + 1);

                /* lldpRemIndex in objId */
                /* it's the agents own index  */
                current[vp->namelen+1] = pRemoteSender->OidRemEntry.RemIndex;

                 /* we take one ProtocolIndex only, SYNTAX Integer32 (1..2147483647) */
                current[vp->namelen+2] = 1;

                if (oper)   /* operation is SET or GET */
                {
                    if (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) == 0)
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found       = LSA_TRUE;
                        break;   /* no need to search further */
                    }
                }
                else     /* caller wants closest match */
                {
                    /* if new one is greater than input and closer to input than
                     * previous lowest, save this one as the "next" one. */
                    if ((oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, name, (unsigned)(*length)) > 0) &&
                        (!Found || (oha_snmp_compare(current, OHA_XREM_ENTRY_OIDLEN+1, lowest, OHA_XREM_ENTRY_OIDLEN+1) < 0)))
                    {
                        OHA_MEMCPY((char *)lowest, (char *)current, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
                        LowSenderId = SenderId;
                        LowPortId   = PortId;
                        LowIfId     = (LSA_UINT16)inter_face;
                        Found       = LSA_TRUE;
                    }
                }
            }
        }   /* end for lldp_mib loop */
    }   /* end for inter_face loop */

    if (Found)  /* a match ? */
    {
        OHA_COMMON_MEM_U8_PTR_TYPE pVar = LSA_NULL;
        LSA_UINT16 Len = 0;
        LSA_UINT8  SubType = 0xff;

        pDB = OHA_GetIf(LowIfId);
        OHA_ASSERT_NULL_PTR(pDB);

        OHA_MEMCPY((char *)name, (char *)lowest, (LSA_UINT32)(vp->namelen+3) * sizeof(OHA_OID));
        *length = (vp->namelen+3);
        *var_len = sizeof long_return;   /* default return length */

        SubType  = LLDP_TLV_IEEE_802_1_TYPE_PROTOCOL_IDENTITY;
        (LSA_VOID)oha_db_read_rem_lldp_element(pDB->NicId, (LSA_UINT16)(LowPortId + 1),
                                               (LSA_UINT16)(LowSenderId + 1), OHA_LLDP_TYPE_ORG_SPECIFIC,
                                               &SubType, OHA_LLDP_TYPE_ORG_OUI_IEEE_802_1,
                                               &pVar, &Len);

        /* return 0, if VLAN is not supported */
        if (OHA_IS_NULL(pVar) ||
            (Len > (LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_LENGTH_SIZE +
                    LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_MAX_LEN)) )
        {
            OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemProtocolEntry() - VLAN Name invalid");
            return(LSA_NULL);
        }

        switch (vp->magic)
        {
            case LLDPXDOT1REMPROTOCOLINDEX: /* lldpXdot1RemProtocolEntry  */ /* not-accessible */
                if (oper != NEXT_OP)  /* oper is a GETNEXT operation */
                {
                    return LSA_NULL;    /* FAIL return.*/
                }
                long_return = 1;  /* we take one ProtocolIndex only, SYNTAX Integer32 (1..2147483647) */
                return (U_CHAR *)&long_return;

            case LLDPXDOT1REMPROTOCOLID:
                /* oha_pdu_get_u8 (long_return, pVar); */
                long_return = (LSA_INT32)OHA_GET8_NTOH (pVar, 0);  /* next byte is protocol ID */
                if (Len == long_return + LLDP_TLV_IEEE_802_1_PROTOCOL_IDENTITY_LENGTH_SIZE)
                {
                    *var_len = (int)long_return;
                }
                else    /* return NULL, if VLAN is not supported */
                {
                    pVar  = LSA_NULL;
                }
                return (U_CHAR *)pVar;

            default:
                OHA_SNMPERROR("var_lldpXdot1RemProtocolEntry(): Unknown magic number");
        }
    }

    OHA_FUNCTION_TRACE_00(0, LSA_TRACE_LEVEL_CHAT, "OUT: var_lldpXdot1RemProtocolEntry() - FAIL return");
    return LSA_NULL;    /* default FAIL return.*/
}

/* Following is a list of traps that can be sent.
   NOTIFICATION-TYPE macro in RFCs enlist the OBJECTs
   to be sent in a specific trap. So when a specific
   trap is to be sent, SNMP will pick varbinds from
   these structures.
*/
/*
struct trapVar nt_lldpRemTablesChange[4] = {
    {{1,0,8802,1,1,2,1,2,2,0xFF},   10, 0,0,LSA_NULL,0 },
    {{1,0,8802,1,1,2,1,2,3,0xFF},   10, 0,0,LSA_NULL,0 },
    {{1,0,8802,1,1,2,1,2,4,0xFF},   10, 0,0,LSA_NULL,0 },
    {{1,0,8802,1,1,2,1,2,5,0xFF},   10, 0,0,LSA_NULL,0 },
};
struct trapVar nt_risingAlarm[5] = {
    {{1,3,6,1,2,1,16,3,1,1,1,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,3,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,4,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,5,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,7,0xFF}, 12, 0,0,LSA_NULL,0 },
};
struct trapVar nt_fallingAlarm[5] = {
    {{1,3,6,1,2,1,16,3,1,1,1,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,3,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,4,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,5,0xFF}, 12, 0,0,LSA_NULL,0 },
    {{1,3,6,1,2,1,16,3,1,1,8,0xFF}, 12, 0,0,LSA_NULL,0 },
};
*/

/* Following is a List of new TEXTUAL CONVENTIONS defined
   in the MIBs
*/
struct snmp_enumList oha_en_TruthValue[] =
{
    { "true", 1 },
    { "false", 2 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_RowStatus[] =
{
    { "active", 1 },
    { "notInService", 2 },
    { "notReady", 3 },
    { "createAndGo", 4 },
    { "createAndWait", 5 },
    { "destroy", 6 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_StorageType[] =
{
    { "other", 1 },
    { "volatile", 2 },
    { "nonVolatile", 3 },
    { "permanent", 4 },
    { "readOnly", 5 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_SnmpSecurityLevel[] =
{
    { "noAuthNoPriv", 1 },
    { "authNoPriv", 2 },
    { "authPriv", 3 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_EntryStatus[] =
{
    { "valid", 1 },
    { "createRequest", 2 },
    { "underCreation", 3 },
    { "invalid", 4 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_AddressFamilyNumbers[] =
{
    { "other", 0 },
    { "ipV4", 1 },
    { "ipV6", 2 },
    { "nsap", 3 },
    { "hdlc", 4 },
    { "bbn1822", 5 },
    { "all802", 6 },
    { "e163", 7 },
    { "e164", 8 },
    { "f69", 9 },
    { "x121", 10 },
    { "ipx", 11 },
    { "appleTalk", 12 },
    { "decnetIV", 13 },
    { "banyanVines", 14 },
    { "e164withNsap", 15 },
    { "dns", 16 },
    { "distinguishedName", 17 },
    { "asNumber", 18 },
    { "xtpOverIpv4", 19 },
    { "xtpOverIpv6", 20 },
    { "xtpNativeModeXTP", 21 },
    { "fibreChannelWWPN", 22 },
    { "fibreChannelWWNN", 23 },
    { "gwid", 24 },
    { "reserved", 65535 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpChassisIdSubtype[] =
{
    { "chassisComponent", 1 },
    { "interfaceAlias", 2 },
    { "portComponent", 3 },
    { "macAddress", 4 },
    { "networkAddress", 5 },
    { "interfaceName", 6 },
    { "local", 7 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpPortIdSubtype[] =
{
    { "interfaceAlias", 1 },
    { "portComponent", 2 },
    { "macAddress", 3 },
    { "networkAddress", 4 },
    { "interfaceName", 5 },
    { "agentCircuitId", 6 },
    { "local", 7 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpManAddrIfSubtype[] =
{
    { "unknown", 1 },
    { "ifIndex", 2 },
    { "systemPortNumber", 3 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpSystemCapabilitiesMap[] =
{
    { "other", 0 },
    { "repeater", 1 },
    { "bridge", 2 },
    { "wlanAccessPoint", 3 },
    { "router", 4 },
    { "telephone", 5 },
    { "docsisCableDevice", 6 },
    { "stationOnly", 7 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_EnabledStatus[] =
{
    { "enabled", 1 },
    { "disabled", 2 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpPowerPortClass[] =
{
    { "pClassPSE", 1 },
    { "pClassPD", 2 },
    { LSA_NULL, 0 }
};

struct snmp_enumList oha_en_LldpLinkAggStatusMap[] =
{
    { "aggCapable", 0 },
    { "aggEnabled", 1 },
    { LSA_NULL, 0 }
};

/* end of file oha_mibs.c */

